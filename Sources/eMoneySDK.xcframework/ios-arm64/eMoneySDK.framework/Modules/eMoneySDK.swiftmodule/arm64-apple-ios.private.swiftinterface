// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9 (swiftlang-5.9.0.128.108 clang-1500.0.40.1)
// swift-module-flags: -target arm64-apple-ios12.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name eMoneySDK
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFoundation
import Alamofire
import CommonCrypto
import CoreGraphics
import CoreImage
import CoreLocation
import CryptoKit
import Darwin
import DeveloperToolsSupport
import EFRSDK
import Foundation
import Kingfisher
import LeanSDK
import LocalAuthentication
import Lottie
import MDRSDK
import PassKit
import Photos
import QuartzCore
import Swift
import SwiftMessages
import SwiftUI
import UIKit
import Vision
import WebKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@_exported import eMoneySDK
import os.log
import os
@_hasMissingDesignatedInitializers @objc(FloatingPanelGrabberView) @_Concurrency.MainActor(unsafe) public class GrabberView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public var barColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func hitTest(_ point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
  @objc deinit
}
public struct HKDF {
  public enum Error : Swift.Error {
    case invalidInput
    case derivedKeyTooLong
    public static func == (a: eMoneySDK.HKDF.Error, b: eMoneySDK.HKDF.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>? = nil, info: Swift.Array<Swift.UInt8>? = nil, keyLength: Swift.Int? = nil, variant: eMoneySDK.HMAC.Variant = .sha2(.sha256)) throws
  public func calculate() throws -> Swift.Array<Swift.UInt8>
}
public struct CCM {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case invalidParameter
    case fail
    public static func == (a: eMoneySDK.CCM.Error, b: eMoneySDK.CCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: eMoneySDK.BlockModeOption
  public let customBlockSize: Swift.Int?
  public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping eMoneySDK.CipherOperationOnBlock, encryptionOperation: @escaping eMoneySDK.CipherOperationOnBlock) throws -> any eMoneySDK.CipherModeWorker
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class AOModalStatusView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public func set(image: UIKit.UIImage)
  @_Concurrency.MainActor(unsafe) public func set(headline text: Swift.String)
  @_Concurrency.MainActor(unsafe) public func set(subheading text: Swift.String)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func didMoveToSuperview()
  @objc deinit
}
extension eMoneySDK.DropDown {
  @_Concurrency.MainActor(unsafe) final public class func setupDefaultAppearance()
}
public protocol Cryptor {
  mutating func seek(to: Swift.Int) throws
}
extension eMoneySDK.AES {
  convenience public init(key: Swift.String, iv: Swift.String, padding: eMoneySDK.Padding = .pkcs7) throws
}
@_inheritsConvenienceInitializers public class ThinWormDrawer : eMoneySDK.AdvancedPageControlDrawerParentWithIndicator, eMoneySDK.AdvancedPageControlDraw {
  public func draw(_ rect: CoreFoundation.CGRect)
  override public init(numberOfPages: Swift.Int? = super, height: CoreFoundation.CGFloat? = super, width: CoreFoundation.CGFloat? = super, space: CoreFoundation.CGFloat? = super, raduis: CoreFoundation.CGFloat? = super, currentItem: CoreFoundation.CGFloat? = super, indicatorColor: UIKit.UIColor? = super, dotsColor: UIKit.UIColor? = super, isBordered: Swift.Bool = super, borderColor: UIKit.UIColor = super, borderWidth: CoreFoundation.CGFloat = super, indicatorBorderColor: UIKit.UIColor = super, indicatorBorderWidth: CoreFoundation.CGFloat = super)
  @objc deinit
}
public struct CFB : eMoneySDK.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: eMoneySDK.CFB.Error, b: eMoneySDK.CFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum SegmentSize : Swift.Int {
    case cfb8
    case cfb128
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public let options: eMoneySDK.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>, segmentSize: eMoneySDK.CFB.SegmentSize = .cfb128)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping eMoneySDK.CipherOperationOnBlock, encryptionOperation: @escaping eMoneySDK.CipherOperationOnBlock) throws -> any eMoneySDK.CipherModeWorker
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class InternetConnectionErrorViewController : eMoneySDK.BaseViewController {
  @_Concurrency.MainActor(unsafe) @objc convenience dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@_inheritsConvenienceInitializers public class ColorBlendDrawer : eMoneySDK.AdvancedPageControlDrawerParentWithIndicator, eMoneySDK.AdvancedPageControlDraw {
  public func draw(_ rect: CoreFoundation.CGRect)
  override public init(numberOfPages: Swift.Int? = super, height: CoreFoundation.CGFloat? = super, width: CoreFoundation.CGFloat? = super, space: CoreFoundation.CGFloat? = super, raduis: CoreFoundation.CGFloat? = super, currentItem: CoreFoundation.CGFloat? = super, indicatorColor: UIKit.UIColor? = super, dotsColor: UIKit.UIColor? = super, isBordered: Swift.Bool = super, borderColor: UIKit.UIColor = super, borderWidth: CoreFoundation.CGFloat = super, indicatorBorderColor: UIKit.UIColor = super, indicatorBorderWidth: CoreFoundation.CGFloat = super)
  @objc deinit
}
extension eMoneySDK.CS.BigUInt {
  public static func randomInteger<RNG>(withMaximumWidth width: Swift.Int, using generator: inout RNG) -> eMoneySDK.CS.BigUInt where RNG : Swift.RandomNumberGenerator
  public static func randomInteger(withMaximumWidth width: Swift.Int) -> eMoneySDK.CS.BigUInt
  public static func randomInteger<RNG>(withExactWidth width: Swift.Int, using generator: inout RNG) -> eMoneySDK.CS.BigUInt where RNG : Swift.RandomNumberGenerator
  public static func randomInteger(withExactWidth width: Swift.Int) -> eMoneySDK.CS.BigUInt
  public static func randomInteger<RNG>(lessThan limit: eMoneySDK.CS.BigUInt, using generator: inout RNG) -> eMoneySDK.CS.BigUInt where RNG : Swift.RandomNumberGenerator
  public static func randomInteger(lessThan limit: eMoneySDK.CS.BigUInt) -> eMoneySDK.CS.BigUInt
}
@_inheritsConvenienceInitializers public class WormDrawer : eMoneySDK.AdvancedPageControlDrawerParentWithIndicator, eMoneySDK.AdvancedPageControlDraw {
  public func draw(_ rect: CoreFoundation.CGRect)
  override public init(numberOfPages: Swift.Int? = super, height: CoreFoundation.CGFloat? = super, width: CoreFoundation.CGFloat? = super, space: CoreFoundation.CGFloat? = super, raduis: CoreFoundation.CGFloat? = super, currentItem: CoreFoundation.CGFloat? = super, indicatorColor: UIKit.UIColor? = super, dotsColor: UIKit.UIColor? = super, isBordered: Swift.Bool = super, borderColor: UIKit.UIColor = super, borderWidth: CoreFoundation.CGFloat = super, indicatorBorderColor: UIKit.UIColor = super, indicatorBorderWidth: CoreFoundation.CGFloat = super)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class BaseViewController : UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension eMoneySDK.CS.BigUInt {
  public func quotientAndRemainder(dividingBy y: eMoneySDK.CS.BigUInt) -> (quotient: eMoneySDK.CS.BigUInt, remainder: eMoneySDK.CS.BigUInt)
  public static func / (x: eMoneySDK.CS.BigUInt, y: eMoneySDK.CS.BigUInt) -> eMoneySDK.CS.BigUInt
  public static func % (x: eMoneySDK.CS.BigUInt, y: eMoneySDK.CS.BigUInt) -> eMoneySDK.CS.BigUInt
  public static func /= (x: inout eMoneySDK.CS.BigUInt, y: eMoneySDK.CS.BigUInt)
  public static func %= (x: inout eMoneySDK.CS.BigUInt, y: eMoneySDK.CS.BigUInt)
}
extension eMoneySDK.CS.BigInt {
  public func quotientAndRemainder(dividingBy y: eMoneySDK.CS.BigInt) -> (quotient: eMoneySDK.CS.BigInt, remainder: eMoneySDK.CS.BigInt)
  public static func / (a: eMoneySDK.CS.BigInt, b: eMoneySDK.CS.BigInt) -> eMoneySDK.CS.BigInt
  public static func % (a: eMoneySDK.CS.BigInt, b: eMoneySDK.CS.BigInt) -> eMoneySDK.CS.BigInt
  public func modulus(_ mod: eMoneySDK.CS.BigInt) -> eMoneySDK.CS.BigInt
}
extension eMoneySDK.CS.BigInt {
  public static func /= (a: inout eMoneySDK.CS.BigInt, b: eMoneySDK.CS.BigInt)
  public static func %= (a: inout eMoneySDK.CS.BigInt, b: eMoneySDK.CS.BigInt)
}
extension eMoneySDK.CS.BigUInt {
  public func greatestCommonDivisor(with b: eMoneySDK.CS.BigUInt) -> eMoneySDK.CS.BigUInt
  public func inverse(_ modulus: eMoneySDK.CS.BigUInt) -> eMoneySDK.CS.BigUInt?
}
extension eMoneySDK.CS.BigInt {
  public func greatestCommonDivisor(with b: eMoneySDK.CS.BigInt) -> eMoneySDK.CS.BigInt
  public func inverse(_ modulus: eMoneySDK.CS.BigInt) -> eMoneySDK.CS.BigInt?
}
extension eMoneySDK.BetterSegmentedControl {
  @objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) open class IndicatorView : UIKit.UIView {
    @_Concurrency.MainActor(unsafe) @objc override dynamic open var frame: CoreFoundation.CGRect {
      @objc get
      @objc set
    }
    @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
    @objc deinit
  }
}
public protocol OTPTextFieldData : AnyObject {
  func numberOfPins() -> Swift.Int
  func otpTextField(viewAt index: Swift.Int) -> any eMoneySDK.PinContainer
  func otpTextField(sizeForViewAt index: Swift.Int) -> CoreFoundation.CGSize
  func spaceBetweenViews() -> CoreFoundation.CGFloat
  func showSeperatorBetweenFields() -> Swift.Bool
  func showBorderOnMainView() -> Swift.Bool
}
public protocol TypographyExtensions : UIKit.UILabel {
  var lineHeight: CoreFoundation.CGFloat? { get set }
}
extension UIKit.UILabel : eMoneySDK.TypographyExtensions {
  @_Concurrency.MainActor(unsafe) public var lineHeight: CoreFoundation.CGFloat? {
    get
    set
  }
}
public class CMAC : eMoneySDK.Authenticator {
  public enum Error : Swift.Error {
    case wrongKeyLength
    public static func == (a: eMoneySDK.CMAC.Error, b: eMoneySDK.CMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(key: Swift.Array<Swift.UInt8>) throws
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>, cipher: any eMoneySDK.Cipher) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
@_hasMissingDesignatedInitializers public class SDKNavigationStack {
  @objc deinit
}
public class IconWithLabel {
  public init(icon: UIKit.UIImage, title: Swift.String)
  @objc deinit
}
@_inheritsConvenienceInitializers public class SwapDrawer : eMoneySDK.AdvancedPageControlDrawerParentWithIndicator, eMoneySDK.AdvancedPageControlDraw {
  public func draw(_ rect: CoreFoundation.CGRect)
  override public init(numberOfPages: Swift.Int? = super, height: CoreFoundation.CGFloat? = super, width: CoreFoundation.CGFloat? = super, space: CoreFoundation.CGFloat? = super, raduis: CoreFoundation.CGFloat? = super, currentItem: CoreFoundation.CGFloat? = super, indicatorColor: UIKit.UIColor? = super, dotsColor: UIKit.UIColor? = super, isBordered: Swift.Bool = super, borderColor: UIKit.UIColor = super, borderWidth: CoreFoundation.CGFloat = super, indicatorBorderColor: UIKit.UIColor = super, indicatorBorderWidth: CoreFoundation.CGFloat = super)
  @objc deinit
}
extension eMoneySDK.CS.BigUInt {
  public init(_ buffer: Swift.UnsafeRawBufferPointer)
  public init(_ data: Foundation.Data)
  public func serialize() -> Foundation.Data
}
extension eMoneySDK.CS.BigInt {
  public init(_ buffer: Swift.UnsafeRawBufferPointer)
  public init(_ data: Foundation.Data)
  public func serialize() -> Foundation.Data
}
@_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@objc @_Concurrency.MainActor(unsafe) open class IQPreviousNextView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public protocol Updatable {
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
extension eMoneySDK.Updatable {
  @inlinable public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    let processed = try update(withBytes: bytes, isLast: isLast)
    if !processed.isEmpty {
      output(processed)
    }
  }
  @inlinable public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes, isLast: isLast)
  }
  @inlinable public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes.slice, isLast: isLast)
  }
  @inlinable public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.update(withBytes: bytes.slice, isLast: isLast, output: output)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes, isLast: true)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    try self.finish(withBytes: bytes.slice)
  }
  @inlinable public mutating func finish() throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: [], isLast: true)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    let processed = try update(withBytes: bytes, isLast: true)
    if !processed.isEmpty {
      output(processed)
    }
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.finish(withBytes: bytes.slice, output: output)
  }
  @inlinable public mutating func finish(output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.finish(withBytes: [], output: output)
  }
}
extension eMoneySDK.CS.BigUInt {
  public func power(_ exponent: Swift.Int) -> eMoneySDK.CS.BigUInt
  public func power(_ exponent: eMoneySDK.CS.BigUInt, modulus: eMoneySDK.CS.BigUInt) -> eMoneySDK.CS.BigUInt
}
extension eMoneySDK.CS.BigInt {
  public func power(_ exponent: Swift.Int) -> eMoneySDK.CS.BigInt
  public func power(_ exponent: eMoneySDK.CS.BigInt, modulus: eMoneySDK.CS.BigInt) -> eMoneySDK.CS.BigInt
}
@objc public protocol FloatingPanelBehavior {
  @objc optional var springDecelerationRate: CoreFoundation.CGFloat { get }
  @objc optional var springResponseTime: CoreFoundation.CGFloat { get }
  @objc optional var momentumProjectionRate: CoreFoundation.CGFloat { get }
  @objc optional func shouldProjectMomentum(_ fpc: eMoneySDK.FloatingPanelController, to proposedTargetPosition: eMoneySDK.FloatingPanelState) -> Swift.Bool
  @objc optional func redirectionalProgress(_ fpc: eMoneySDK.FloatingPanelController, from: eMoneySDK.FloatingPanelState, to: eMoneySDK.FloatingPanelState) -> CoreFoundation.CGFloat
  @objc optional func allowsRubberBanding(for edge: UIKit.UIRectEdge) -> Swift.Bool
  @objc optional var removalInteractionVelocityThreshold: CoreFoundation.CGFloat { get }
}
open class FloatingPanelDefaultBehavior : eMoneySDK.FloatingPanelBehavior {
  public init()
  @objc open var springDecelerationRate: CoreFoundation.CGFloat {
    @objc get
  }
  @objc open var springResponseTime: CoreFoundation.CGFloat {
    @objc get
  }
  @objc open var momentumProjectionRate: CoreFoundation.CGFloat {
    @objc get
  }
  @objc open func redirectionalProgress(_ fpc: eMoneySDK.FloatingPanelController, from: eMoneySDK.FloatingPanelState, to: eMoneySDK.FloatingPanelState) -> CoreFoundation.CGFloat
  @objc open func allowsRubberBanding(for edge: UIKit.UIRectEdge) -> Swift.Bool
  @objc open var removalInteractionVelocityThreshold: CoreFoundation.CGFloat
  @objc deinit
}
extension eMoneySDK.CS.BigUInt : Swift.Comparable {
  public static func compare(_ a: eMoneySDK.CS.BigUInt, _ b: eMoneySDK.CS.BigUInt) -> Foundation.ComparisonResult
  public static func == (a: eMoneySDK.CS.BigUInt, b: eMoneySDK.CS.BigUInt) -> Swift.Bool
  public static func < (a: eMoneySDK.CS.BigUInt, b: eMoneySDK.CS.BigUInt) -> Swift.Bool
}
extension eMoneySDK.CS.BigInt {
  public static func == (a: eMoneySDK.CS.BigInt, b: eMoneySDK.CS.BigInt) -> Swift.Bool
  public static func < (a: eMoneySDK.CS.BigInt, b: eMoneySDK.CS.BigInt) -> Swift.Bool
}
public protocol Localizable {
  var localized: Swift.String { get }
}
extension Swift.String : eMoneySDK.Localizable {
  public var localized: Swift.String {
    get
  }
}
extension UIKit.UILabel {
  @objc @_Concurrency.MainActor(unsafe) dynamic public func cstmlayoutSubviews()
}
public protocol PinContainer : AnyObject {
  var view: UIKit.UIView { get }
  func set(value: Swift.String?)
  func clear()
  func setupState(isActive: Swift.Bool, isError: Swift.Bool)
}
extension eMoneySDK.PinContainer where Self : UIKit.UIView {
  public var view: UIKit.UIView {
    get
  }
}
@_inheritsConvenienceInitializers @objc(FloatingPanelSurfaceAppearance) @objcMembers public class SurfaceAppearance : ObjectiveC.NSObject {
  @_inheritsConvenienceInitializers @objc(FloatingPanelSurfaceAppearanceShadow) public class Shadow : ObjectiveC.NSObject {
    @objc public var hidden: Swift.Bool
    @objc public var color: UIKit.UIColor
    @objc public var offset: CoreFoundation.CGSize
    @objc public var opacity: Swift.Float
    @objc public var radius: CoreFoundation.CGFloat
    @objc public var spread: CoreFoundation.CGFloat
    @objc override dynamic public init()
    @objc deinit
  }
  @objc public var backgroundColor: UIKit.UIColor?
  @objc public var cornerRadius: CoreFoundation.CGFloat
  @objc @available(iOS 13.0, *)
  public var cornerCurve: QuartzCore.CALayerCornerCurve {
    @objc get
    @objc set
  }
  @objc public var shadows: [eMoneySDK.SurfaceAppearance.Shadow]
  @objc public var borderColor: UIKit.UIColor?
  @objc public var borderWidth: CoreFoundation.CGFloat
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(FloatingPanelSurfaceView) @objcMembers @_Concurrency.MainActor(unsafe) public class SurfaceView : UIKit.UIView {
  @objc @_Concurrency.MainActor(unsafe) final public let grabberHandle: eMoneySDK.GrabberView
  @objc @_Concurrency.MainActor(unsafe) public var grabberHandlePadding: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) public var grabberAreaOffset: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor(unsafe) public var grabberHandleSize: CoreFoundation.CGSize {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) weak public var contentView: UIKit.UIView?
  @objc @_Concurrency.MainActor(unsafe) public var contentPadding: UIKit.UIEdgeInsets {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var backgroundColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) public var appearance: eMoneySDK.SurfaceAppearance {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) public var containerMargins: UIKit.UIEdgeInsets {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public let containerView: UIKit.UIView
  @_Concurrency.MainActor(unsafe) @objc override dynamic public class var requiresConstraintBasedLayout: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func updateConstraints()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @objc deinit
}
public protocol AEAD {
  static var kLen: Swift.Int { get }
  static var ivRange: Swift.Range<Swift.Int> { get }
}
@_inheritsConvenienceInitializers public class JumpDrawer : eMoneySDK.AdvancedPageControlDrawerParentWithIndicator, eMoneySDK.AdvancedPageControlDraw {
  public func draw(_ rect: CoreFoundation.CGRect)
  override public init(numberOfPages: Swift.Int? = super, height: CoreFoundation.CGFloat? = super, width: CoreFoundation.CGFloat? = super, space: CoreFoundation.CGFloat? = super, raduis: CoreFoundation.CGFloat? = super, currentItem: CoreFoundation.CGFloat? = super, indicatorColor: UIKit.UIColor? = super, dotsColor: UIKit.UIColor? = super, isBordered: Swift.Bool = super, borderColor: UIKit.UIColor = super, borderWidth: CoreFoundation.CGFloat = super, indicatorBorderColor: UIKit.UIColor = super, indicatorBorderWidth: CoreFoundation.CGFloat = super)
  @objc deinit
}
@objc public protocol FloatingPanelLayout {
  @objc var position: eMoneySDK.FloatingPanelPosition { get }
  @objc var initialState: eMoneySDK.FloatingPanelState { get }
  @objc var anchors: [eMoneySDK.FloatingPanelState : any eMoneySDK.FloatingPanelLayoutAnchoring] { get }
  @objc optional func prepareLayout(surfaceView: UIKit.UIView, in view: UIKit.UIView) -> [UIKit.NSLayoutConstraint]
  @objc optional func backdropAlpha(for state: eMoneySDK.FloatingPanelState) -> CoreFoundation.CGFloat
}
@objc @_inheritsConvenienceInitializers @objcMembers open class FloatingPanelBottomLayout : ObjectiveC.NSObject, eMoneySDK.FloatingPanelLayout {
  @objc override dynamic public init()
  @objc open var initialState: eMoneySDK.FloatingPanelState {
    @objc get
  }
  @objc open var anchors: [eMoneySDK.FloatingPanelState : any eMoneySDK.FloatingPanelLayoutAnchoring] {
    @objc get
  }
  @objc open var position: eMoneySDK.FloatingPanelPosition {
    @objc get
  }
  @objc open func prepareLayout(surfaceView: UIKit.UIView, in view: UIKit.UIView) -> [UIKit.NSLayoutConstraint]
  @objc open func backdropAlpha(for state: eMoneySDK.FloatingPanelState) -> CoreFoundation.CGFloat
  @objc deinit
}
public struct OFB : eMoneySDK.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: eMoneySDK.OFB.Error, b: eMoneySDK.OFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: eMoneySDK.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping eMoneySDK.CipherOperationOnBlock, encryptionOperation: @escaping eMoneySDK.CipherOperationOnBlock) throws -> any eMoneySDK.CipherModeWorker
}
final public class Checksum {
  @usableFromInline
  internal static let table32: [Swift.UInt32]
  @usableFromInline
  internal static let table32c: [Swift.UInt32]
  @usableFromInline
  internal static let table16: [Swift.UInt16]
  @usableFromInline
  internal init()
  @inlinable final internal func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    var crc: UInt32 = seed != nil ? seed! : 0xFFFF_FFFF
    for chunk in message.batched(by: 256) {
      for b in chunk {
        let idx = Int((crc ^ UInt32(reflect ? b : reversed(b))) & 0xFF)
        crc = (crc >> 8) ^ Checksum.table32[idx]
      }
    }
    return (reflect ? crc : reversed(crc)) ^ 0xFFFF_FFFF
  }
  @inlinable final internal func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    var crc: UInt32 = seed != nil ? seed! : 0xFFFF_FFFF
    for chunk in message.batched(by: 256) {
      for b in chunk {
        let idx = Int((crc ^ UInt32(reflect ? b : reversed(b))) & 0xFF)
        crc = (crc >> 8) ^ Checksum.table32c[idx]
      }
    }
    return (reflect ? crc : reversed(crc)) ^ 0xFFFF_FFFF
  }
  @inlinable final internal func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16 {
    var crc: UInt16 = seed != nil ? seed! : 0x0000
    for chunk in message.batched(by: 256) {
      for b in chunk {
        crc = (crc >> 8) ^ Checksum.table16[Int((crc ^ UInt16(b)) & 0xFF)]
      }
    }
    return crc
  }
  @objc deinit
}
extension eMoneySDK.Checksum {
  @inlinable public static func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    Checksum().crc32(message, seed: seed, reflect: reflect)
  }
  @inlinable public static func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    Checksum().crc32c(message, seed: seed, reflect: reflect)
  }
  @inlinable public static func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16 {
    Checksum().crc16(message, seed: seed)
  }
}
final public class Blowfish {
  public enum Error : Swift.Error {
    case dataPaddingRequired
    case invalidKeyOrInitializationVector
    case invalidInitializationVector
    case invalidBlockMode
    public static func == (a: eMoneySDK.Blowfish.Error, b: eMoneySDK.Blowfish.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, blockMode: any eMoneySDK.BlockMode = CBC(iv: Array<UInt8>(repeating: 0, count: Blowfish.blockSize)), padding: eMoneySDK.Padding) throws
  @objc deinit
}
extension eMoneySDK.Blowfish : eMoneySDK.Cipher {
  final public func encrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
  final public func decrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
}
@usableFromInline
final internal class StreamDecryptor : eMoneySDK.Cryptor, eMoneySDK.Updatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal var worker: any eMoneySDK.CipherModeWorker
  @usableFromInline
  final internal let padding: eMoneySDK.Padding
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var lastBlockRemainder: Swift.Int
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: eMoneySDK.Padding, _ worker: any eMoneySDK.CipherModeWorker) throws
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    let toProcess = self.accumulated.prefix(max(self.accumulated.count - self.worker.additionalBufferSize, 0))

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      // will truncate suffix if needed
      try finalizingWorker.willDecryptLast(bytes: self.accumulated.slice)
    }

    var processedBytesCount = 0
    var plaintext = Array<UInt8>(reserveCapacity: bytes.count + self.worker.additionalBufferSize)
    for chunk in toProcess.batched(by: self.blockSize) {
      plaintext += self.worker.decrypt(block: chunk)
      processedBytesCount += chunk.count
    }

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
    }

    // omit unecessary calculation if not needed
    if self.padding != .noPadding {
      self.lastBlockRemainder = plaintext.count.quotientAndRemainder(dividingBy: self.blockSize).remainder
    }

    if isLast {
      // CTR doesn't need padding. Really. Add padding to the last block if really want. but... don't.
      plaintext = self.padding.remove(from: plaintext, blockSize: self.blockSize - self.lastBlockRemainder)
    }

    self.accumulated.removeFirst(processedBytesCount) // super-slow

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      plaintext = Array(try finalizingWorker.finalize(decrypt: plaintext.slice))
    }

    return plaintext
  }
  @inlinable final public func seek(to position: Swift.Int) throws {
    guard var worker = self.worker as? SeekableModeWorker else {
      fatalError("Not supported")
    }

    try worker.seek(to: position)
    self.worker = worker
  }
  @objc @usableFromInline
  deinit
}
extension eMoneySDK.Rabbit {
  convenience public init(key: Swift.String) throws
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
public struct CTR {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: eMoneySDK.CTR.Error, b: eMoneySDK.CTR.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: eMoneySDK.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>, counter: Swift.Int = 0)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping eMoneySDK.CipherOperationOnBlock, encryptionOperation: @escaping eMoneySDK.CipherOperationOnBlock) throws -> any eMoneySDK.CipherModeWorker
}
@_inheritsConvenienceInitializers public class ScaleDrawer : eMoneySDK.AdvancedPageControlDrawerParentWithIndicator, eMoneySDK.AdvancedPageControlDraw {
  public func draw(_ rect: CoreFoundation.CGRect)
  override public init(numberOfPages: Swift.Int? = super, height: CoreFoundation.CGFloat? = super, width: CoreFoundation.CGFloat? = super, space: CoreFoundation.CGFloat? = super, raduis: CoreFoundation.CGFloat? = super, currentItem: CoreFoundation.CGFloat? = super, indicatorColor: UIKit.UIColor? = super, dotsColor: UIKit.UIColor? = super, isBordered: Swift.Bool = super, borderColor: UIKit.UIColor = super, borderWidth: CoreFoundation.CGFloat = super, indicatorBorderColor: UIKit.UIColor = super, indicatorBorderWidth: CoreFoundation.CGFloat = super)
  @objc deinit
}
public protocol _UInt8Type {
}
extension Swift.UInt8 : eMoneySDK._UInt8Type {
}
extension Swift.UInt8 {
  public func bits() -> [eMoneySDK.Bit]
  public func bits() -> Swift.String
}
extension Swift.FixedWidthInteger {
  @inlinable internal func bytes(totalBytes: Swift.Int = MemoryLayout<Self>.size) -> Swift.Array<Swift.UInt8> {
    arrayOfBytes(value: self.littleEndian, length: totalBytes)
    // TODO: adjust bytes order
    // var value = self.littleEndian
    // return withUnsafeBytes(of: &value, Array.init).reversed()
  }
}
@objc @_inheritsConvenienceInitializers final public class DefaultTextFieldAdapter : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
extension eMoneySDK.DefaultTextFieldAdapter : eMoneySDK.OTPTextFieldData {
  final public func showBorderOnMainView() -> Swift.Bool
  final public func showSeperatorBetweenFields() -> Swift.Bool
  final public func spaceBetweenViews() -> CoreFoundation.CGFloat
  final public func numberOfPins() -> Swift.Int
  final public func otpTextField(viewAt index: Swift.Int) -> any eMoneySDK.PinContainer
  final public func otpTextField(sizeForViewAt index: Swift.Int) -> CoreFoundation.CGSize
}
public enum Bit : Swift.Int {
  case zero
  case one
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension eMoneySDK.Bit {
  @inlinable internal func inverted() -> eMoneySDK.Bit {
    self == .zero ? .one : .zero
  }
}
extension Swift.String {
  public func formatFor(phoneNumber: Swift.String, shouldRemoveLastDigit: Swift.Bool = false) -> Swift.String
  public var formattedPhoneNumber: Swift.String {
    get
  }
  public var planPhoneNumberString: Swift.String {
    get
  }
}
public typealias BigInteger = eMoneySDK.CS.BigInt
public typealias BigUInteger = eMoneySDK.CS.BigUInt
public enum CS {
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class FloatingSegmentedControl : UIKit.UIView, eMoneySDK.NibInstantiatable {
  @_Concurrency.MainActor(unsafe) weak open var target: ObjectiveC.NSObject?
  @_Concurrency.MainActor(unsafe) public var action: ObjectiveC.Selector?
  @_Concurrency.MainActor(unsafe) public var isAnimateFocusMoving: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var focusedIndex: Swift.Int {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func awakeFromNib()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func prepareForInterfaceBuilder()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) public func setSegments(with titles: [Swift.String])
  @_Concurrency.MainActor(unsafe) public func move(to index: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func addTarget(_ target: ObjectiveC.NSObject, action selector: ObjectiveC.Selector)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class OnboardingViewController : UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) public var onSuccess: ((Swift.String) -> ())?
  @_Concurrency.MainActor(unsafe) public var onFailure: ((Swift.String, Swift.String) -> ())?
  @_Concurrency.MainActor(unsafe) public var clientID: Swift.String?
  @_Concurrency.MainActor(unsafe) public var partnerName: Swift.String?
  @_Concurrency.MainActor(unsafe) public var msisdn: Swift.String?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidAppear(_ animdated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func shouldPerformSegue(withIdentifier identifier: Swift.String, sender: Any?) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func prepare(for segue: UIKit.UIStoryboardSegue, sender: Any?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class RegisterMobileNumberViewController : eMoneySDK.BaseViewController {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension eMoneySDK.AES : eMoneySDK.Cryptors {
  @inlinable final public func makeEncryptor() throws -> any eMoneySDK.Cryptor & eMoneySDK.Updatable {
    let blockSize = blockMode.customBlockSize ?? AES.blockSize
    let worker = try blockMode.worker(blockSize: blockSize, cipherOperation: encrypt, encryptionOperation: encrypt)
    if worker is StreamModeWorker {
      return try StreamEncryptor(blockSize: blockSize, padding: padding, worker)
    }
    return try BlockEncryptor(blockSize: blockSize, padding: padding, worker)
  }
  @inlinable final public func makeDecryptor() throws -> any eMoneySDK.Cryptor & eMoneySDK.Updatable {
    let blockSize = blockMode.customBlockSize ?? AES.blockSize
    let cipherOperation: CipherOperationOnBlock = blockMode.options.contains(.useEncryptToDecrypt) == true ? encrypt : decrypt
    let worker = try blockMode.worker(blockSize: blockSize, cipherOperation: cipherOperation, encryptionOperation: encrypt)
    if worker is StreamModeWorker {
      return try StreamDecryptor(blockSize: blockSize, padding: padding, worker)
    }
    return try BlockDecryptor(blockSize: blockSize, padding: padding, worker)
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class DropDownCell : UIKit.UITableViewCell {
  @objc @IBOutlet @_Concurrency.MainActor(unsafe) weak open var optionLabel: UIKit.UILabel!
  @available(iOS 3.0, *)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension eMoneySDK.DropDownCell {
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func awakeFromNib()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isSelected: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func setHighlighted(_ highlighted: Swift.Bool, animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func setSelected(_ selected: Swift.Bool, animated: Swift.Bool)
}
@objc open class FloatingPanelState : ObjectiveC.NSObject, Foundation.NSCopying, Swift.RawRepresentable {
  public typealias RawValue = Swift.String
  required public init?(rawValue: eMoneySDK.FloatingPanelState.RawValue)
  @objc public init(rawValue: eMoneySDK.FloatingPanelState.RawValue, order: Swift.Int)
  final public let rawValue: eMoneySDK.FloatingPanelState.RawValue
  final public let order: Swift.Int
  @objc public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc override dynamic public var debugDescription: Swift.String {
    @objc get
  }
  @objc(Full) public static let full: eMoneySDK.FloatingPanelState
  @objc(Half) public static let half: eMoneySDK.FloatingPanelState
  @objc(Tip) public static let tip: eMoneySDK.FloatingPanelState
  @objc(Hidden) public static let hidden: eMoneySDK.FloatingPanelState
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
@objc final public class IQInvocation : ObjectiveC.NSObject {
  @objc weak final public var target: Swift.AnyObject?
  @objc final public var action: ObjectiveC.Selector
  @objc public init(_ target: Swift.AnyObject, _ action: ObjectiveC.Selector)
  @objc final public func invoke(from: Any)
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
@objc public enum IQAutoToolbarManageBehaviour : Swift.Int {
  case bySubviews
  case byTag
  case byPosition
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@available(iOSApplicationExtension, unavailable)
@objc public enum IQPreviousNextDisplayMode : Swift.Int {
  case `default`
  case alwaysHide
  case alwaysShow
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@available(iOSApplicationExtension, unavailable)
@objc public enum IQEnableMode : Swift.Int {
  case `default`
  case enabled
  case disabled
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
final public class ChaCha20 {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    case notSupported
    public static func == (a: eMoneySDK.ChaCha20.Error, b: eMoneySDK.ChaCha20.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, iv nonce: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
extension eMoneySDK.ChaCha20 : eMoneySDK.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension eMoneySDK.ChaCha20 {
  public struct ChaChaEncryptor : eMoneySDK.Cryptor, eMoneySDK.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension eMoneySDK.ChaCha20 {
  public struct ChaChaDecryptor : eMoneySDK.Cryptor, eMoneySDK.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = true) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension eMoneySDK.ChaCha20 : eMoneySDK.Cryptors {
  final public func makeEncryptor() -> any eMoneySDK.Cryptor & eMoneySDK.Updatable
  final public func makeDecryptor() -> any eMoneySDK.Cryptor & eMoneySDK.Updatable
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor(unsafe) open class FSPageControl : UIKit.UIControl {
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var numberOfPages: Swift.Int {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var currentPage: Swift.Int {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var itemSpacing: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var interitemSpacing: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var contentInsets: UIKit.UIEdgeInsets {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var contentHorizontalAlignment: UIKit.UIControl.ContentHorizontalAlignment {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var hidesForSinglePage: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSublayers(of layer: QuartzCore.CALayer)
  @objc(setStrokeColor:forState:) @_Concurrency.MainActor(unsafe) open func setStrokeColor(_ strokeColor: UIKit.UIColor?, for state: UIKit.UIControl.State)
  @objc(setFillColor:forState:) @_Concurrency.MainActor(unsafe) open func setFillColor(_ fillColor: UIKit.UIColor?, for state: UIKit.UIControl.State)
  @objc(setImage:forState:) @_Concurrency.MainActor(unsafe) open func setImage(_ image: UIKit.UIImage?, for state: UIKit.UIControl.State)
  @objc(setAlpha:forState:) @_Concurrency.MainActor(unsafe) open func setAlpha(_ alpha: CoreFoundation.CGFloat, for state: UIKit.UIControl.State)
  @objc(setPath:forState:) @_Concurrency.MainActor(unsafe) open func setPath(_ path: UIKit.UIBezierPath?, for state: UIKit.UIControl.State)
  @objc deinit
}
extension UIKit.UIControl.State : Swift.Hashable {
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Cryptors : AnyObject {
  func makeEncryptor() throws -> any eMoneySDK.Cryptor & eMoneySDK.Updatable
  func makeDecryptor() throws -> any eMoneySDK.Cryptor & eMoneySDK.Updatable
  static func randomIV(_ blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension eMoneySDK.Cryptors {
  public static func randomIV(_ count: Swift.Int) -> Swift.Array<Swift.UInt8>
}
public enum CipherError : Swift.Error {
  case encrypt
  case decrypt
  public static func == (a: eMoneySDK.CipherError, b: eMoneySDK.CipherError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Cipher : AnyObject {
  var keySize: Swift.Int { get }
  func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension eMoneySDK.Cipher {
  public func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
@available(iOSApplicationExtension, unavailable)
extension eMoneySDK.IQKeyboardManager {
  @objc final public func reloadInputViews()
}
@available(iOSApplicationExtension, unavailable)
extension eMoneySDK.IQKeyboardManager {
  @objc final public var canGoPrevious: Swift.Bool {
    @objc get
  }
  @objc final public var canGoNext: Swift.Bool {
    @objc get
  }
  @discardableResult
  @objc final public func goPrevious() -> Swift.Bool
  @discardableResult
  @objc final public func goNext() -> Swift.Bool
}
@available(iOSApplicationExtension, unavailable)
@objc extension UIKit.UIScrollView {
  @objc @_Concurrency.MainActor(unsafe) dynamic public var shouldIgnoreScrollingAdjustment: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var shouldIgnoreContentInsetAdjustment: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var shouldRestoreScrollViewContentOffset: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
}
@_inheritsConvenienceInitializers final public class CBCMAC : eMoneySDK.CMAC {
  override final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  override public init(key: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
@_inheritsConvenienceInitializers public class ExtendedDotDrawer : eMoneySDK.AdvancedPageControlDrawerParentWithIndicator, eMoneySDK.AdvancedPageControlDraw {
  public func draw(_ rect: CoreFoundation.CGRect)
  override public init(numberOfPages: Swift.Int? = super, height: CoreFoundation.CGFloat? = super, width: CoreFoundation.CGFloat? = super, space: CoreFoundation.CGFloat? = super, raduis: CoreFoundation.CGFloat? = super, currentItem: CoreFoundation.CGFloat? = super, indicatorColor: UIKit.UIColor? = super, dotsColor: UIKit.UIColor? = super, isBordered: Swift.Bool = super, borderColor: UIKit.UIColor = super, borderWidth: CoreFoundation.CGFloat = super, indicatorBorderColor: UIKit.UIColor = super, indicatorBorderWidth: CoreFoundation.CGFloat = super)
  @objc deinit
}
@inlinable internal func rotateLeft(_ value: Swift.UInt8, by: Swift.UInt8) -> Swift.UInt8 {
  ((value << by) & 0xff) | (value >> (8 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  ((value << by) & 0xffff) | (value >> (16 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  ((value << by) & 0xffffffff) | (value >> (32 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  (value << by) | (value >> (64 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  (value >> by) | (value << (16 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  (value >> by) | (value << (32 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  ((value >> by) | (value << (64 - by)))
}
@inlinable internal func reversed(_ uint8: Swift.UInt8) -> Swift.UInt8 {
  var v = uint8
  v = (v & 0xf0) >> 4 | (v & 0x0f) << 4
  v = (v & 0xcc) >> 2 | (v & 0x33) << 2
  v = (v & 0xaa) >> 1 | (v & 0x55) << 1
  return v
}
@inlinable internal func reversed(_ uint32: Swift.UInt32) -> Swift.UInt32 {
  var v = uint32
  v = ((v >> 1) & 0x55555555) | ((v & 0x55555555) << 1)
  v = ((v >> 2) & 0x33333333) | ((v & 0x33333333) << 2)
  v = ((v >> 4) & 0x0f0f0f0f) | ((v & 0x0f0f0f0f) << 4)
  v = ((v >> 8) & 0x00ff00ff) | ((v & 0x00ff00ff) << 8)
  v = ((v >> 16) & 0xffff) | ((v & 0xffff) << 16)
  return v
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.ArraySlice<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  return xor(left, right).slice
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.Array<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  let length = Swift.min(left.count, right.count)

  let buf = UnsafeMutablePointer<UInt8>.allocate(capacity: length)
  buf.initialize(repeating: 0, count: length)
  defer {
    buf.deinitialize(count: length)
    buf.deallocate()
  }

  // xor
  for i in 0..<length {
    buf[i] = left[left.startIndex.advanced(by: i)] ^ right[right.startIndex.advanced(by: i)]
  }

  return Array(UnsafeBufferPointer(start: buf, count: length))
}
@inline(__always) @inlinable internal func bitPadding(to data: inout Swift.Array<Swift.UInt8>, blockSize: Swift.Int, allowance: Swift.Int = 0) {
  let msgLength = data.count
  // Step 1. Append Padding Bits
  // append one bit (UInt8 with one bit) to message
  data.append(0x80)

  // Step 2. append "0" bit until message length in bits  448 (mod 512)
  let max = blockSize - allowance // 448, 986
  if msgLength % blockSize < max { // 448
    data += Array<UInt8>(repeating: 0, count: max - 1 - (msgLength % blockSize))
  } else {
    data += Array<UInt8>(repeating: 0, count: blockSize + max - 1 - (msgLength % blockSize))
  }
}
@_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@objc @_Concurrency.MainActor(unsafe) open class IQTextView : UIKit.UITextView {
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect, textContainer: UIKit.NSTextContainer?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func awakeFromNib()
  @objc deinit
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var placeholderTextColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var placeholder: Swift.String? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) open var attributedPlaceholder: Foundation.NSAttributedString? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var text: Swift.String! {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var attributedText: Foundation.NSAttributedString! {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var font: UIKit.UIFont? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var textAlignment: UIKit.NSTextAlignment {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override weak dynamic open var delegate: (any UIKit.UITextViewDelegate)? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
}
@available(iOS 13.4, *)
extension eMoneySDK.BetterSegmentedControl : UIKit.UIPointerInteractionDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func pointerInteraction(_ interaction: UIKit.UIPointerInteraction, regionFor request: UIKit.UIPointerRegionRequest, defaultRegion: UIKit.UIPointerRegion) -> UIKit.UIPointerRegion?
  @_Concurrency.MainActor(unsafe) @objc dynamic public func pointerInteraction(_ interaction: UIKit.UIPointerInteraction, styleFor region: UIKit.UIPointerRegion) -> UIKit.UIPointerStyle?
}
extension eMoneySDK.BetterSegmentedControl {
  @_Concurrency.MainActor(unsafe) public class func appleStyled(frame: CoreFoundation.CGRect, titles: [Swift.String]) -> eMoneySDK.BetterSegmentedControl
}
extension UIKit.UIImage {
  public func flipIfNeeded() -> UIKit.UIImage?
}
@objc public protocol FloatingPanelLayoutAnchoring {
  @objc var referenceGuide: eMoneySDK.FloatingPanelLayoutReferenceGuide { get }
  @objc func layoutConstraints(_ fpc: eMoneySDK.FloatingPanelController, for position: eMoneySDK.FloatingPanelPosition) -> [UIKit.NSLayoutConstraint]
}
@objc final public class FloatingPanelLayoutAnchor : ObjectiveC.NSObject, eMoneySDK.FloatingPanelLayoutAnchoring {
  @objc public init(absoluteInset: CoreFoundation.CGFloat, edge: eMoneySDK.FloatingPanelReferenceEdge, referenceGuide: eMoneySDK.FloatingPanelLayoutReferenceGuide)
  @objc public init(fractionalInset: CoreFoundation.CGFloat, edge: eMoneySDK.FloatingPanelReferenceEdge, referenceGuide: eMoneySDK.FloatingPanelLayoutReferenceGuide)
  @objc final public let referenceGuide: eMoneySDK.FloatingPanelLayoutReferenceGuide
  @objc deinit
}
extension eMoneySDK.FloatingPanelLayoutAnchor {
  @objc final public func layoutConstraints(_ vc: eMoneySDK.FloatingPanelController, for position: eMoneySDK.FloatingPanelPosition) -> [UIKit.NSLayoutConstraint]
}
@objc final public class FloatingPanelIntrinsicLayoutAnchor : ObjectiveC.NSObject, eMoneySDK.FloatingPanelLayoutAnchoring {
  @objc public init(absoluteOffset offset: CoreFoundation.CGFloat, referenceGuide: eMoneySDK.FloatingPanelLayoutReferenceGuide = .safeArea)
  @objc public init(fractionalOffset offset: CoreFoundation.CGFloat, referenceGuide: eMoneySDK.FloatingPanelLayoutReferenceGuide = .safeArea)
  @objc final public let referenceGuide: eMoneySDK.FloatingPanelLayoutReferenceGuide
  @objc deinit
}
extension eMoneySDK.FloatingPanelIntrinsicLayoutAnchor {
  @objc final public func layoutConstraints(_ vc: eMoneySDK.FloatingPanelController, for position: eMoneySDK.FloatingPanelPosition) -> [UIKit.NSLayoutConstraint]
}
@objc final public class FloatingPanelAdaptiveLayoutAnchor : ObjectiveC.NSObject, eMoneySDK.FloatingPanelLayoutAnchoring {
  @objc public init(absoluteOffset offset: CoreFoundation.CGFloat, contentLayout: UIKit.UILayoutGuide, referenceGuide: eMoneySDK.FloatingPanelLayoutReferenceGuide, contentBoundingGuide: eMoneySDK.FloatingPanelLayoutContentBoundingGuide = .none)
  @objc public init(fractionalOffset offset: CoreFoundation.CGFloat, contentLayout: UIKit.UILayoutGuide, referenceGuide: eMoneySDK.FloatingPanelLayoutReferenceGuide, contentBoundingGuide: eMoneySDK.FloatingPanelLayoutContentBoundingGuide = .none)
  @objc final public let referenceGuide: eMoneySDK.FloatingPanelLayoutReferenceGuide
  @objc final public let contentBoundingGuide: eMoneySDK.FloatingPanelLayoutContentBoundingGuide
  @objc deinit
}
extension eMoneySDK.FloatingPanelAdaptiveLayoutAnchor {
  @objc final public func layoutConstraints(_ vc: eMoneySDK.FloatingPanelController, for position: eMoneySDK.FloatingPanelPosition) -> [UIKit.NSLayoutConstraint]
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class FSPagerViewCell : UIKit.UICollectionViewCell {
  @objc @_Concurrency.MainActor(unsafe) open var textLabel: UIKit.UILabel? {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) open var imageView: UIKit.UIImageView? {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isSelected: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func observeValue(forKeyPath keyPath: Swift.String?, of object: Any?, change: [Foundation.NSKeyValueChangeKey : Any]?, context: Swift.UnsafeMutableRawPointer?)
}
extension eMoneySDK.BetterSegmentedControl {
  public enum Option {
    case indicatorViewBackgroundColor(UIKit.UIColor)
    case indicatorViewInset(CoreFoundation.CGFloat)
    case indicatorViewBorderWidth(CoreFoundation.CGFloat)
    case indicatorViewBorderColor(UIKit.UIColor)
    case alwaysAnnouncesValue(Swift.Bool)
    case announcesValueImmediately(Swift.Bool)
    case panningDisabled(Swift.Bool)
    case animationDuration(Foundation.TimeInterval)
    case animationSpringDamping(CoreFoundation.CGFloat)
    case backgroundColor(UIKit.UIColor)
    case cornerRadius(CoreFoundation.CGFloat)
  }
}
extension eMoneySDK.CS.BigUInt {
  public subscript(bitAt index: Swift.Int) -> Swift.Bool {
    get
    set
  }
}
extension eMoneySDK.CS.BigUInt {
  public var bitWidth: Swift.Int {
    get
  }
  public var leadingZeroBitCount: Swift.Int {
    get
  }
  public var trailingZeroBitCount: Swift.Int {
    get
  }
}
extension eMoneySDK.CS.BigInt {
  public var bitWidth: Swift.Int {
    get
  }
  public var trailingZeroBitCount: Swift.Int {
    get
  }
}
extension eMoneySDK.CS.BigUInt {
  public struct Words : Swift.RandomAccessCollection {
    public var startIndex: Swift.Int {
      get
    }
    public var endIndex: Swift.Int {
      get
    }
    public subscript(index: Swift.Int) -> eMoneySDK.CS.BigUInt.Word {
      get
    }
    public typealias Element = eMoneySDK.CS.BigUInt.Word
    public typealias Index = Swift.Int
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias Iterator = Swift.IndexingIterator<eMoneySDK.CS.BigUInt.Words>
    public typealias SubSequence = Swift.Slice<eMoneySDK.CS.BigUInt.Words>
  }
  public var words: eMoneySDK.CS.BigUInt.Words {
    get
  }
  public init<Words>(words: Words) where Words : Swift.Sequence, Words.Element == Swift.UInt
}
extension eMoneySDK.CS.BigInt {
  public struct Words : Swift.RandomAccessCollection {
    public typealias Indices = Swift.CountableRange<Swift.Int>
    public var count: Swift.Int {
      get
    }
    public var indices: eMoneySDK.CS.BigInt.Words.Indices {
      get
    }
    public var startIndex: Swift.Int {
      get
    }
    public var endIndex: Swift.Int {
      get
    }
    public subscript(index: Swift.Int) -> Swift.UInt {
      get
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<eMoneySDK.CS.BigInt.Words>
    public typealias SubSequence = Swift.Slice<eMoneySDK.CS.BigInt.Words>
  }
  public var words: eMoneySDK.CS.BigInt.Words {
    get
  }
  public init<S>(words: S) where S : Swift.Sequence, S.Element == Swift.UInt
}
public protocol AdvancedPageControlDraw {
  var currentItem: CoreFoundation.CGFloat { get set }
  var size: CoreFoundation.CGFloat { get set }
  var numberOfPages: Swift.Int { get set }
  func draw(_ rect: CoreFoundation.CGRect)
}
public class AdvancedPageControlDrawerParentWithIndicator : eMoneySDK.AdvancedPageControlDrawerParent {
  public init(numberOfPages: Swift.Int? = 5, height: CoreFoundation.CGFloat? = 16, width: CoreFoundation.CGFloat? = 16, space: CoreFoundation.CGFloat? = 16, raduis: CoreFoundation.CGFloat? = 8, currentItem: CoreFoundation.CGFloat? = 0, indicatorColor: UIKit.UIColor? = .lightGray, dotsColor: UIKit.UIColor? = UIColor.lightGray, isBordered: Swift.Bool = false, borderColor: UIKit.UIColor = .lightGray, borderWidth: CoreFoundation.CGFloat = 1, indicatorBorderColor: UIKit.UIColor = .lightGray, indicatorBorderWidth: CoreFoundation.CGFloat = 2)
  @objc deinit
}
public class AdvancedPageControlDrawerParent {
  public var numberOfPages: Swift.Int
  public var size: CoreFoundation.CGFloat
  public var currentItem: CoreFoundation.CGFloat
  public var items: [Swift.Int]
  public init(numberOfPages: Swift.Int? = 5, height: CoreFoundation.CGFloat? = 16, width: CoreFoundation.CGFloat? = 16, space: CoreFoundation.CGFloat? = 16, raduis: CoreFoundation.CGFloat? = 16, currentItem: CoreFoundation.CGFloat? = 0, dotsColor: UIKit.UIColor? = UIColor.lightGray, isBordered: Swift.Bool = false, borderColor: UIKit.UIColor = .lightGray, borderWidth: CoreFoundation.CGFloat = 1)
  @objc deinit
}
@available(*, renamed: "Digest")
public typealias Hash = eMoneySDK.Digest
public struct Digest {
  public static func md5(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha1(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha224(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha256(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha384(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha512(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha2(_ bytes: Swift.Array<Swift.UInt8>, variant: eMoneySDK.SHA2.Variant) -> Swift.Array<Swift.UInt8>
  public static func sha3(_ bytes: Swift.Array<Swift.UInt8>, variant: eMoneySDK.SHA3.Variant) -> Swift.Array<Swift.UInt8>
}
@objc public enum FSPagerViewTransformerType : Swift.Int {
  case crossFading
  case zoomOut
  case depth
  case overlap
  case linear
  case coverFlow
  case ferrisWheel
  case invertedFerrisWheel
  case cubic
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc open class FSPagerViewTransformer : ObjectiveC.NSObject {
  weak open var pagerView: eMoneySDK.FSPagerView? {
    get
  }
  open var type: eMoneySDK.FSPagerViewTransformerType {
    get
  }
  @objc open var minimumScale: CoreFoundation.CGFloat
  @objc open var minimumAlpha: CoreFoundation.CGFloat
  @objc public init(type: eMoneySDK.FSPagerViewTransformerType)
  open func applyTransform(to attributes: eMoneySDK.FSPagerViewLayoutAttributes)
  open func proposedInteritemSpacing() -> CoreFoundation.CGFloat
  @objc deinit
}
extension UIKit.UISpringTimingParameters {
  @_Concurrency.MainActor(unsafe) convenience public init(decelerationRate: CoreFoundation.CGFloat, frequencyResponse: CoreFoundation.CGFloat, initialVelocity: CoreFoundation.CGVector = .zero)
  @_Concurrency.MainActor(unsafe) convenience public init(dampingRatio: CoreFoundation.CGFloat, frequencyResponse: CoreFoundation.CGFloat, initialVelocity: CoreFoundation.CGVector = .zero)
}
extension eMoneySDK.CS.BigUInt : Swift.Strideable {
  public typealias Stride = eMoneySDK.CS.BigInt
  public func advanced(by n: eMoneySDK.CS.BigInt) -> eMoneySDK.CS.BigUInt
  public func distance(to other: eMoneySDK.CS.BigUInt) -> eMoneySDK.CS.BigInt
}
extension eMoneySDK.CS.BigInt : Swift.Strideable {
  public typealias Stride = eMoneySDK.CS.BigInt
  public func advanced(by n: eMoneySDK.CS.BigInt.Stride) -> eMoneySDK.CS.BigInt
  public func distance(to other: eMoneySDK.CS.BigInt) -> eMoneySDK.CS.BigInt.Stride
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class FSPagerViewLayoutAttributes : UIKit.UICollectionViewLayoutAttributes {
  @_Concurrency.MainActor(unsafe) open var position: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func isEqual(_ object: Any?) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init()
  @objc deinit
}
extension eMoneySDK.CS.BigUInt {
  public func squareRoot() -> eMoneySDK.CS.BigUInt
}
extension eMoneySDK.CS.BigInt {
  public func squareRoot() -> eMoneySDK.CS.BigInt
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class AdvancedPageControlView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public var numberOfPages: Swift.Int {
    get
    set(val)
  }
  @_Concurrency.MainActor(unsafe) public var drawer: any eMoneySDK.AdvancedPageControlDraw
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) public func setPageOffset(_ offset: CoreFoundation.CGFloat)
  @_Concurrency.MainActor(unsafe) public func setPage(_ index: Swift.Int)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func draw(_ rect: CoreFoundation.CGRect)
  @objc deinit
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func gradientBorder(width: CoreFoundation.CGFloat, colors: [UIKit.UIColor], startPoint: CoreFoundation.CGPoint = CGPoint(x: 0.5, y: 0.0), endPoint: CoreFoundation.CGPoint = CGPoint(x: 0.5, y: 1.0), andRoundCornersWithRadius cornerRadius: CoreFoundation.CGFloat = 0)
  @_Concurrency.MainActor(unsafe) public func getExistingGradientLayer(layerName: Swift.String) -> QuartzCore.CAGradientLayer?
  @_Concurrency.MainActor(unsafe) public func roundCorners(corners: UIKit.UIRectCorner, radius: CoreFoundation.CGFloat)
  @_Concurrency.MainActor(unsafe) public func addGradient(colors: [UIKit.UIColor], locations: [Foundation.NSNumber]?, startPoint: CoreFoundation.CGPoint, endPoint: CoreFoundation.CGPoint, cornerRadius: CoreFoundation.CGFloat = 16)
}
@_hasMissingDesignatedInitializers public class LoginModel {
  final public let result: Swift.String?, userToken: Swift.String?, fullName: Swift.String?
  final public let isDigitalKyc: Swift.Bool?
  public var profileName: Swift.String?
  final public let isSingleAccount: Swift.Bool?, isEIDSuspended: Swift.Bool?
  final public let isFirstLogin: Swift.Bool?
  final public let loyaltyPointsAccountsFri: Swift.String?, fri: Swift.String?
  final public let oldDeviceId: Swift.String?
  public var pin: Swift.String
  public var retriesLeft: Swift.Int?
  public var remainingDays: Swift.Int?
  public var noOfDaysPendingForPhysicalVer: Swift.Int?
  public var upgradeScreen: Swift.String?
  public var upgradeToProfile: Swift.String?
  public var flowName: Swift.String?
  public var survey: Swift.String?
  public var errors: [Swift.String]?
  @objc deinit
}
@_hasMissingDesignatedInitializers public class BaseResponse {
  final public let responseCode: Swift.Int
  public var responseMessage: Swift.String?
  public var title: Swift.String?
  public var message: Swift.String?
  public var displayAppRating: Swift.Bool?
  final public let data: eMoneySDK.LoginModel
  @objc deinit
}
public struct CBC : eMoneySDK.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: eMoneySDK.CBC.Error, b: eMoneySDK.CBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: eMoneySDK.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping eMoneySDK.CipherOperationOnBlock, encryptionOperation: @escaping eMoneySDK.CipherOperationOnBlock) throws -> any eMoneySDK.CipherModeWorker
}
@available(iOSApplicationExtension, unavailable)
@objc extension UIKit.UIView {
  @objc @_Concurrency.MainActor(unsafe) dynamic public func viewContainingController() -> UIKit.UIViewController?
  @objc @_Concurrency.MainActor(unsafe) dynamic public func topMostController() -> UIKit.UIViewController?
  @objc @_Concurrency.MainActor(unsafe) dynamic public func parentContainerViewController() -> UIKit.UIViewController?
  @objc @_Concurrency.MainActor(unsafe) dynamic public func superviewOfClassType(_ classType: UIKit.UIView.Type, belowView: UIKit.UIView? = nil) -> UIKit.UIView?
}
@_inheritsConvenienceInitializers public class InfiniteDrawer : eMoneySDK.AdvancedPageControlDrawerParentWithIndicator, eMoneySDK.AdvancedPageControlDraw {
  public func draw(_ rect: CoreFoundation.CGRect)
  override public init(numberOfPages: Swift.Int? = super, height: CoreFoundation.CGFloat? = super, width: CoreFoundation.CGFloat? = super, space: CoreFoundation.CGFloat? = super, raduis: CoreFoundation.CGFloat? = super, currentItem: CoreFoundation.CGFloat? = super, indicatorColor: UIKit.UIColor? = super, dotsColor: UIKit.UIColor? = super, isBordered: Swift.Bool = super, borderColor: UIKit.UIColor = super, borderWidth: CoreFoundation.CGFloat = super, indicatorBorderColor: UIKit.UIColor = super, indicatorBorderWidth: CoreFoundation.CGFloat = super)
  @objc deinit
}
public enum FontName : Swift.String {
  case Regular
  case SemiBold
  case Medium
  case Light
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum FontSize : CoreFoundation.CGFloat {
  case body5
  case body4
  case body3
  case body2
  case body1
  case h7
  case h6
  case h5, h4
  case h3
  case h2
  case h1
  public init?(rawValue: CoreFoundation.CGFloat)
  public typealias RawValue = CoreFoundation.CGFloat
  public var rawValue: CoreFoundation.CGFloat {
    get
  }
}
public struct AppFont {
  public static func font(name: eMoneySDK.FontName, size: eMoneySDK.FontSize) -> UIKit.UIFont
  public static func appRegular(size: eMoneySDK.FontSize) -> UIKit.UIFont
  public static func appSemiBold(size: eMoneySDK.FontSize) -> UIKit.UIFont
  public static func appMedium(size: eMoneySDK.FontSize) -> UIKit.UIFont
  public static func appLight(size: eMoneySDK.FontSize) -> UIKit.UIFont
}
@usableFromInline
final internal class BlockEncryptor : eMoneySDK.Cryptor, eMoneySDK.Updatable {
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: eMoneySDK.Padding, _ worker: any eMoneySDK.CipherModeWorker) throws
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  @usableFromInline
  final internal func seek(to: Swift.Int) throws
  @objc @usableFromInline
  deinit
}
extension eMoneySDK.CS.BigUInt {
  public mutating func subtractReportingOverflow(_ b: eMoneySDK.CS.BigUInt, shiftedBy shift: Swift.Int = 0) -> Swift.Bool
  public func subtractingReportingOverflow(_ other: eMoneySDK.CS.BigUInt, shiftedBy shift: Swift.Int) -> (partialValue: eMoneySDK.CS.BigUInt, overflow: Swift.Bool)
  public func subtractingReportingOverflow(_ other: eMoneySDK.CS.BigUInt) -> (partialValue: eMoneySDK.CS.BigUInt, overflow: Swift.Bool)
  public mutating func subtract(_ other: eMoneySDK.CS.BigUInt, shiftedBy shift: Swift.Int = 0)
  public func subtracting(_ other: eMoneySDK.CS.BigUInt, shiftedBy shift: Swift.Int = 0) -> eMoneySDK.CS.BigUInt
  public mutating func decrement(shiftedBy shift: Swift.Int = 0)
  public static func - (a: eMoneySDK.CS.BigUInt, b: eMoneySDK.CS.BigUInt) -> eMoneySDK.CS.BigUInt
  public static func -= (a: inout eMoneySDK.CS.BigUInt, b: eMoneySDK.CS.BigUInt)
}
extension eMoneySDK.CS.BigInt {
  public mutating func negate()
  public static func - (a: eMoneySDK.CS.BigInt, b: eMoneySDK.CS.BigInt) -> eMoneySDK.CS.BigInt
  public static func -= (a: inout eMoneySDK.CS.BigInt, b: eMoneySDK.CS.BigInt)
}
@objc public enum FloatingPanelPosition : Swift.Int {
  case top
  case left
  case bottom
  case right
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public protocol Authenticator {
  func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public protocol NibInstantiatable {
  static var nibName: Swift.String { get }
  static func nib(inBundle bundle: Foundation.Bundle?) -> UIKit.UINib
  static func fromNib<T>(inBundle bundle: Foundation.Bundle?, filesOwner: Any?) -> T where T : UIKit.UIView
}
extension eMoneySDK.NibInstantiatable where Self : UIKit.UIView {
  public static var nibName: Swift.String {
    get
  }
  public static func nib(inBundle bundle: Foundation.Bundle?) -> UIKit.UINib
  public static func fromNib<T>(inBundle bundle: Foundation.Bundle? = nil, filesOwner: Any? = nil) -> T where T : UIKit.UIView
}
public enum NVActivityIndicatorType : Swift.CaseIterable {
  case blank
  case ballPulse
  case ballGridPulse
  case ballClipRotate
  case squareSpin
  case ballClipRotatePulse
  case ballClipRotateMultiple
  case ballPulseRise
  case ballRotate
  case cubeTransition
  case ballZigZag
  case ballZigZagDeflect
  case ballTrianglePath
  case ballScale
  case lineScale
  case lineScaleParty
  case ballScaleMultiple
  case ballPulseSync
  case ballBeat
  case ballDoubleBounce
  case lineScalePulseOut
  case lineScalePulseOutRapid
  case ballScaleRipple
  case ballScaleRippleMultiple
  case ballSpinFadeLoader
  case lineSpinFadeLoader
  case triangleSkewSpin
  case pacman
  case ballGridBeat
  case semiCircleSpin
  case ballRotateChase
  case orbit
  case audioEqualizer
  case circleStrokeSpin
  public static func == (a: eMoneySDK.NVActivityIndicatorType, b: eMoneySDK.NVActivityIndicatorType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [eMoneySDK.NVActivityIndicatorType]
  public static var allCases: [eMoneySDK.NVActivityIndicatorType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public typealias FadeInAnimation = (UIKit.UIView) -> Swift.Void
public typealias FadeOutAnimation = (UIKit.UIView, @escaping () -> Swift.Void) -> Swift.Void
@objc @_Concurrency.MainActor(unsafe) final public class NVActivityIndicatorView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_TYPE: eMoneySDK.NVActivityIndicatorType
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_COLOR: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_TEXT_COLOR: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_PADDING: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_SIZE: CoreFoundation.CGSize
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_DISPLAY_TIME_THRESHOLD: Swift.Int
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_MINIMUM_DISPLAY_TIME: Swift.Int
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_MESSAGE: Swift.String?
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_MESSAGE_SPACING: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_MESSAGE_FONT: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_BACKGROUND_COLOR: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_FADE_IN_ANIMATION: (_ view: UIKit.UIView) -> Swift.Void
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_FADE_OUT_ANIMATION: (_ view: UIKit.UIView, _ complete: @escaping () -> Swift.Void) -> Swift.Void
  @_Concurrency.MainActor(unsafe) final public var type: eMoneySDK.NVActivityIndicatorType
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) final public var color: UIKit.UIColor
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) final public var padding: CoreFoundation.CGFloat
  @available(*, deprecated)
  @_Concurrency.MainActor(unsafe) final public var animating: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var isAnimating: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public init(frame: CoreFoundation.CGRect, type: eMoneySDK.NVActivityIndicatorType? = nil, color: UIKit.UIColor? = nil, padding: CoreFoundation.CGFloat? = nil)
  @_Concurrency.MainActor(unsafe) @objc override final public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public var bounds: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) final public func startAnimating()
  @_Concurrency.MainActor(unsafe) final public func stopAnimating()
  @objc deinit
}
public protocol PaddingProtocol {
  func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
}
public enum Padding : eMoneySDK.PaddingProtocol {
  case noPadding, zeroPadding, pkcs7, pkcs5, eme_pkcs1v15, emsa_pkcs1v15, iso78164, iso10126
  public func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  public func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
  public static func == (a: eMoneySDK.Padding, b: eMoneySDK.Padding) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class BaseInputView : UIKit.UIView, UIKit.UITextInput {
  @_Concurrency.MainActor(unsafe) @objc public var hasText: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc public func insertText(_ text: Swift.String)
  @_Concurrency.MainActor(unsafe) @objc public func deleteBackward()
  @_Concurrency.MainActor(unsafe) @objc public var selectedTextRange: UIKit.UITextRange? {
    @objc get
    @objc set(selectedTextRange)
  }
  @_Concurrency.MainActor(unsafe) @objc public var markedTextRange: UIKit.UITextRange? {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc public var markedTextStyle: [Foundation.NSAttributedString.Key : Any]? {
    @objc get
    @objc set(markedTextStyle)
  }
  @_Concurrency.MainActor(unsafe) @objc public var beginningOfDocument: UIKit.UITextPosition {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc public var endOfDocument: UIKit.UITextPosition {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc public var inputDelegate: (any UIKit.UITextInputDelegate)? {
    @objc get
    @objc set(inputDelegate)
  }
  @_Concurrency.MainActor(unsafe) @objc public var tokenizer: any UIKit.UITextInputTokenizer {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc public func replace(_ range: UIKit.UITextRange, withText text: Swift.String)
  @_Concurrency.MainActor(unsafe) @objc public func setMarkedText(_ markedText: Swift.String?, selectedRange: Foundation.NSRange)
  @_Concurrency.MainActor(unsafe) @objc public func unmarkText()
  @_Concurrency.MainActor(unsafe) @objc public func textRange(from fromPosition: UIKit.UITextPosition, to toPosition: UIKit.UITextPosition) -> UIKit.UITextRange?
  @_Concurrency.MainActor(unsafe) @objc public func position(from position: UIKit.UITextPosition, offset: Swift.Int) -> UIKit.UITextPosition?
  @_Concurrency.MainActor(unsafe) @objc public func position(from position: UIKit.UITextPosition, in direction: UIKit.UITextLayoutDirection, offset: Swift.Int) -> UIKit.UITextPosition?
  @_Concurrency.MainActor(unsafe) @objc public func compare(_ position: UIKit.UITextPosition, to other: UIKit.UITextPosition) -> Foundation.ComparisonResult
  @_Concurrency.MainActor(unsafe) @objc public func offset(from: UIKit.UITextPosition, to toPosition: UIKit.UITextPosition) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc public func position(within range: UIKit.UITextRange, farthestIn direction: UIKit.UITextLayoutDirection) -> UIKit.UITextPosition?
  @_Concurrency.MainActor(unsafe) @objc public func characterRange(byExtending position: UIKit.UITextPosition, in direction: UIKit.UITextLayoutDirection) -> UIKit.UITextRange?
  @_Concurrency.MainActor(unsafe) @objc public func baseWritingDirection(for position: UIKit.UITextPosition, in direction: UIKit.UITextStorageDirection) -> UIKit.NSWritingDirection
  @_Concurrency.MainActor(unsafe) @objc public func setBaseWritingDirection(_ writingDirection: UIKit.NSWritingDirection, for range: UIKit.UITextRange)
  @_Concurrency.MainActor(unsafe) @objc public func firstRect(for range: UIKit.UITextRange) -> CoreFoundation.CGRect
  @_Concurrency.MainActor(unsafe) @objc public func caretRect(for position: UIKit.UITextPosition) -> CoreFoundation.CGRect
  @_Concurrency.MainActor(unsafe) @objc public func selectionRects(for range: UIKit.UITextRange) -> [UIKit.UITextSelectionRect]
  @_Concurrency.MainActor(unsafe) @objc public func closestPosition(to point: CoreFoundation.CGPoint) -> UIKit.UITextPosition?
  @_Concurrency.MainActor(unsafe) @objc public func closestPosition(to point: CoreFoundation.CGPoint, within range: UIKit.UITextRange) -> UIKit.UITextPosition?
  @_Concurrency.MainActor(unsafe) @objc public func characterRange(at point: CoreFoundation.CGPoint) -> UIKit.UITextRange?
  @_Concurrency.MainActor(unsafe) @objc public func text(in range: UIKit.UITextRange) -> Swift.String?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension eMoneySDK.BaseInputView : UIKit.UITextInputTokenizer {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func rangeEnclosingPosition(_ position: UIKit.UITextPosition, with granularity: UIKit.UITextGranularity, inDirection direction: UIKit.UITextDirection) -> UIKit.UITextRange?
  @_Concurrency.MainActor(unsafe) @objc dynamic public func isPosition(_ position: UIKit.UITextPosition, atBoundary granularity: UIKit.UITextGranularity, inDirection direction: UIKit.UITextDirection) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public func position(from position: UIKit.UITextPosition, toBoundary granularity: UIKit.UITextGranularity, inDirection direction: UIKit.UITextDirection) -> UIKit.UITextPosition?
  @_Concurrency.MainActor(unsafe) @objc dynamic public func isPosition(_ position: UIKit.UITextPosition, withinTextUnit granularity: UIKit.UITextGranularity, inDirection direction: UIKit.UITextDirection) -> Swift.Bool
}
extension eMoneySDK.HMAC {
  convenience public init(key: Swift.String, variant: eMoneySDK.HMAC.Variant = .md5) throws
}
public class EWalletSDK {
  public init(configuration: eMoneySDK.EWalletConfiguration)
  public func startWithOnboarding(in controller: UIKit.UIViewController, msisdn: Swift.String, onSuccess: ((Swift.String) -> ())?, onFailure: ((Swift.String, Swift.String) -> ())?)
  public func startWithAddMoney(in controller: UIKit.UIViewController, msisdn: Swift.String, onSuccess: ((Swift.String) -> ())?, onFailure: ((Swift.String, Swift.String) -> ())?)
  public func startForgetPin(in controller: UIKit.UIViewController, msisdn: Swift.String, onSuccess: ((Swift.String) -> ())?, onFailure: ((Swift.String, Swift.String) -> ())?)
  public func startChangePin(in controller: UIKit.UIViewController, msisdn: Swift.String, onSuccess: ((Swift.String) -> ())?, onFailure: ((Swift.String, Swift.String) -> ())?)
  public func startUpdateEmiratesId(in controller: UIKit.UIViewController, msisdn: Swift.String, onSuccess: ((Swift.String) -> ())?, onFailure: ((Swift.String, Swift.String) -> ())?)
  public func login(in controller: UIKit.UIViewController, msisdn: Swift.String, onSuccess: ((eMoneySDK.BaseResponse) -> ())?, onFailure: ((Swift.String, Swift.String) -> ())?)
  public func enableLogs(_ isEnable: Swift.Bool)
  public func setSDKLanguage(_ language: eMoneySDK.SDKLanguage)
  @objc deinit
}
@_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@objc @_Concurrency.MainActor(unsafe) open class IQBarButtonItem : UIKit.UIBarButtonItem {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var tintColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) open func setTarget(_ target: Swift.AnyObject?, action: ObjectiveC.Selector?)
  @objc @_Concurrency.MainActor(unsafe) open var invocation: eMoneySDK.IQInvocation?
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
extension eMoneySDK.IQKeyboardManager {
  @objc final public var enableDebugging: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc final public func registerAllNotifications()
  @objc final public func unregisterAllNotifications()
  public struct Static {
  }
}
@_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@objc final public class IQKeyboardReturnKeyHandler : ObjectiveC.NSObject {
  @objc weak final public var delegate: (any UIKit.UITextFieldDelegate & UIKit.UITextViewDelegate)?
  @objc final public var lastTextFieldReturnKeyType: UIKit.UIReturnKeyType {
    @objc get
    @objc set
  }
  @objc override dynamic public init()
  @objc public init(controller: UIKit.UIViewController)
  @objc deinit
  @objc final public func addTextFieldView(_ view: UIKit.UIView)
  @objc final public func removeTextFieldView(_ view: UIKit.UIView)
  @objc final public func addResponderFromView(_ view: UIKit.UIView)
  @objc final public func removeResponderFromView(_ view: UIKit.UIView)
}
@available(iOSApplicationExtension, unavailable)
extension eMoneySDK.IQKeyboardReturnKeyHandler : UIKit.UITextFieldDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func textFieldShouldBeginEditing(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func textFieldShouldEndEditing(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func textFieldDidBeginEditing(_ textField: UIKit.UITextField)
  @_Concurrency.MainActor(unsafe) @objc final public func textFieldDidEndEditing(_ textField: UIKit.UITextField)
  @available(iOS 10.0, *)
  @_Concurrency.MainActor(unsafe) @objc final public func textFieldDidEndEditing(_ textField: UIKit.UITextField, reason: UIKit.UITextField.DidEndEditingReason)
  @_Concurrency.MainActor(unsafe) @objc final public func textField(_ textField: UIKit.UITextField, shouldChangeCharactersIn range: Foundation.NSRange, replacementString string: Swift.String) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func textFieldShouldClear(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func textFieldShouldReturn(_ textField: UIKit.UITextField) -> Swift.Bool
}
@available(iOSApplicationExtension, unavailable)
extension eMoneySDK.IQKeyboardReturnKeyHandler : UIKit.UITextViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func textViewShouldBeginEditing(_ textView: UIKit.UITextView) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func textViewShouldEndEditing(_ textView: UIKit.UITextView) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func textViewDidBeginEditing(_ textView: UIKit.UITextView)
  @_Concurrency.MainActor(unsafe) @objc final public func textViewDidEndEditing(_ textView: UIKit.UITextView)
  @_Concurrency.MainActor(unsafe) @objc final public func textView(_ textView: UIKit.UITextView, shouldChangeTextIn range: Foundation.NSRange, replacementText text: Swift.String) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func textViewDidChange(_ textView: UIKit.UITextView)
  @_Concurrency.MainActor(unsafe) @objc final public func textViewDidChangeSelection(_ textView: UIKit.UITextView)
  @available(iOS 10.0, *)
  @_Concurrency.MainActor(unsafe) @objc final public func textView(_ aTextView: UIKit.UITextView, shouldInteractWith URL: Foundation.URL, in characterRange: Foundation.NSRange, interaction: UIKit.UITextItemInteraction) -> Swift.Bool
  @available(iOS 10.0, *)
  @_Concurrency.MainActor(unsafe) @objc final public func textView(_ aTextView: UIKit.UITextView, shouldInteractWith textAttachment: UIKit.NSTextAttachment, in characterRange: Foundation.NSRange, interaction: UIKit.UITextItemInteraction) -> Swift.Bool
  @available(iOS, deprecated: 10.0)
  @_Concurrency.MainActor(unsafe) @objc final public func textView(_ aTextView: UIKit.UITextView, shouldInteractWith URL: Foundation.URL, in characterRange: Foundation.NSRange) -> Swift.Bool
  @available(iOS, deprecated: 10.0)
  @_Concurrency.MainActor(unsafe) @objc final public func textView(_ aTextView: UIKit.UITextView, shouldInteractWith textAttachment: UIKit.NSTextAttachment, in characterRange: Foundation.NSRange) -> Swift.Bool
  @available(iOS 16.0, *)
  @_Concurrency.MainActor(unsafe) @objc final public func textView(_ aTextView: UIKit.UITextView, editMenuForTextIn range: Foundation.NSRange, suggestedActions: [UIKit.UIMenuElement]) -> UIKit.UIMenu?
  @available(iOS 16.0, *)
  @_Concurrency.MainActor(unsafe) @objc final public func textView(_ aTextView: UIKit.UITextView, willPresentEditMenuWith animator: any UIKit.UIEditMenuInteractionAnimating)
  @available(iOS 16.0, *)
  @_Concurrency.MainActor(unsafe) @objc final public func textView(_ aTextView: UIKit.UITextView, willDismissEditMenuWith animator: any UIKit.UIEditMenuInteractionAnimating)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class CustomThumbView : UIKit.UIView {
  @objc deinit
}
extension eMoneySDK.CustomThumbView {
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
}
extension eMoneySDK.PKCS5 {
  public struct PBKDF1 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: eMoneySDK.PKCS5.PBKDF1.Error, b: eMoneySDK.PKCS5.PBKDF1.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum Variant {
      case md5, sha1
      @usableFromInline
      internal var size: Swift.Int {
        get
      }
      @usableFromInline
      internal func calculateHash(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
      public static func == (a: eMoneySDK.PKCS5.PBKDF1.Variant, b: eMoneySDK.PKCS5.PBKDF1.Variant) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    @usableFromInline
    internal let iterations: Swift.Int
    @usableFromInline
    internal let variant: eMoneySDK.PKCS5.PBKDF1.Variant
    @usableFromInline
    internal let keyLength: Swift.Int
    @usableFromInline
    internal let t1: Swift.Array<Swift.UInt8>
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, variant: eMoneySDK.PKCS5.PBKDF1.Variant = .sha1, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil) throws
    @inlinable public func calculate() -> Swift.Array<Swift.UInt8> {
      var t = self.t1
      for _ in 2...self.iterations {
        t = self.variant.calculateHash(t)
      }
      return Array(t[0..<self.keyLength])
    }
  }
}
final public class SHA2 {
  @usableFromInline
  final internal let variant: eMoneySDK.SHA2.Variant
  @usableFromInline
  final internal let size: Swift.Int
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal let digestLength: Swift.Int
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var processedBytesTotalCount: Swift.Int
  @usableFromInline
  final internal var accumulatedHash32: [Swift.UInt32]
  @usableFromInline
  final internal var accumulatedHash64: [Swift.UInt64]
  @frozen public enum Variant : Swift.RawRepresentable {
    case sha224, sha256, sha384, sha512
    public var digestLength: Swift.Int {
      get
    }
    public var blockSize: Swift.Int {
      get
    }
    public typealias RawValue = Swift.Int
    public var rawValue: eMoneySDK.SHA2.Variant.RawValue {
      get
    }
    public init?(rawValue: eMoneySDK.SHA2.Variant.RawValue)
    @usableFromInline
    internal var h: Swift.Array<Swift.UInt64> {
      get
    }
    @usableFromInline
    internal var finalLength: Swift.Int {
      get
    }
  }
  public init(variant: eMoneySDK.SHA2.Variant)
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process64(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.Array<Swift.UInt64>)
  @usableFromInline
  final internal func process32(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.Array<Swift.UInt32>)
  @objc deinit
}
extension eMoneySDK.SHA2 : eMoneySDK.Updatable {
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      let lengthInBits = (processedBytesTotalCount + self.accumulated.count) * 8
      let lengthBytes = lengthInBits.bytes(totalBytes: self.blockSize / 8) // A 64-bit/128-bit representation of b. blockSize fit by accident.

      // Step 1. Append padding
      bitPadding(to: &self.accumulated, blockSize: self.blockSize, allowance: self.blockSize / 8)

      // Step 2. Append Length a 64-bit representation of lengthInBits
      self.accumulated += lengthBytes
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: self.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= self.blockSize {
        switch self.variant {
          case .sha224, .sha256:
            self.process32(block: chunk, currentHash: &self.accumulatedHash32)
          case .sha384, .sha512:
            self.process64(block: chunk, currentHash: &self.accumulatedHash64)
          }
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)
    self.processedBytesTotalCount += processedBytes

    // output current hash
    var result = Array<UInt8>(repeating: 0, count: variant.digestLength)
    switch self.variant {
      case .sha224, .sha256:
        var pos = 0
        for idx in 0..<self.accumulatedHash32.count where idx < self.variant.finalLength {
          let h = accumulatedHash32[idx]
          result[pos + 0] = UInt8((h >> 24) & 0xff)
          result[pos + 1] = UInt8((h >> 16) & 0xff)
          result[pos + 2] = UInt8((h >> 8) & 0xff)
          result[pos + 3] = UInt8(h & 0xff)
          pos += 4
        }
      case .sha384, .sha512:
        var pos = 0
        for idx in 0..<self.accumulatedHash64.count where idx < self.variant.finalLength {
          let h = accumulatedHash64[idx]
          result[pos + 0] = UInt8((h >> 56) & 0xff)
          result[pos + 1] = UInt8((h >> 48) & 0xff)
          result[pos + 2] = UInt8((h >> 40) & 0xff)
          result[pos + 3] = UInt8((h >> 32) & 0xff)
          result[pos + 4] = UInt8((h >> 24) & 0xff)
          result[pos + 5] = UInt8((h >> 16) & 0xff)
          result[pos + 6] = UInt8((h >> 8) & 0xff)
          result[pos + 7] = UInt8(h & 0xff)
          pos += 8
        }
    }

    // reset hash value for instance
    if isLast {
      switch self.variant {
        case .sha224, .sha256:
          self.accumulatedHash32 = self.variant.h.lazy.map { UInt32($0) } // FIXME: UInt64 for process64
        case .sha384, .sha512:
          self.accumulatedHash64 = self.variant.h
      }
    }

    return result
  }
}
public protocol CipherModeWorker {
  var cipherOperation: eMoneySDK.CipherOperationOnBlock { get }
  var additionalBufferSize: Swift.Int { get }
  @inlinable mutating func encrypt(block plaintext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @inlinable mutating func decrypt(block ciphertext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
}
public protocol BlockModeWorker : eMoneySDK.CipherModeWorker {
  var blockSize: Swift.Int { get }
}
public protocol CounterModeWorker : eMoneySDK.CipherModeWorker {
  associatedtype Counter
  var counter: Self.Counter { get set }
}
public protocol SeekableModeWorker : eMoneySDK.CipherModeWorker {
  mutating func seek(to position: Swift.Int) throws
}
public protocol StreamModeWorker : eMoneySDK.CipherModeWorker {
}
public protocol FinalizingEncryptModeWorker : eMoneySDK.CipherModeWorker {
  mutating func finalize(encrypt ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public protocol FinalizingDecryptModeWorker : eMoneySDK.CipherModeWorker {
  @discardableResult
  mutating func willDecryptLast(bytes ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func didDecryptLast(bytes plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func finalize(decrypt plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOSApplicationExtension, unavailable)
@objc @_Concurrency.MainActor(unsafe) open class IQTitleBarButtonItem : eMoneySDK.IQBarButtonItem {
  @objc @_Concurrency.MainActor(unsafe) open var titleFont: UIKit.UIFont? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var title: Swift.String? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) open var titleColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) open var selectableTitleColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override open var invocation: eMoneySDK.IQInvocation? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
public let kIQUseDefaultKeyboardDistance: CoreFoundation.CGFloat
@available(iOSApplicationExtension, unavailable)
@objc extension UIKit.UIView {
  @objc @_Concurrency.MainActor(unsafe) dynamic public var keyboardDistanceFromTextField: CoreFoundation.CGFloat {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var ignoreSwitchingByNextPrevious: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var enableMode: eMoneySDK.IQEnableMode {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var shouldResignOnTouchOutsideMode: eMoneySDK.IQEnableMode {
    @objc get
    @objc set(newValue)
  }
}
final public class AES {
  public enum Error : Swift.Error {
    case invalidKeySize
    case dataPaddingRequired
    case invalidData
    public static func == (a: eMoneySDK.AES.Error, b: eMoneySDK.AES.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant : Swift.Int {
    case aes128, aes192, aes256
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @usableFromInline
  final internal let variantNr: Swift.Int
  @usableFromInline
  final internal let variantNb: Swift.Int
  @usableFromInline
  final internal let variantNk: Swift.Int
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  final public let variant: eMoneySDK.AES.Variant
  @usableFromInline
  final internal let blockMode: any eMoneySDK.BlockMode
  @usableFromInline
  final internal let padding: eMoneySDK.Padding
  @usableFromInline
  final internal var expandedKey: Swift.Array<Swift.Array<Swift.UInt32>> {
    get
    set
  }
  @usableFromInline
  final internal var expandedKeyInv: Swift.Array<Swift.Array<Swift.UInt32>> {
    get
    set
  }
  @usableFromInline
  internal static let T0: [Swift.UInt32]
  @usableFromInline
  internal static let T0_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T1: [Swift.UInt32]
  @usableFromInline
  internal static let T1_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T2: [Swift.UInt32]
  @usableFromInline
  internal static let T2_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T3: [Swift.UInt32]
  @usableFromInline
  internal static let T3_INV: [Swift.UInt32]
  @usableFromInline
  internal static let U1: [Swift.UInt32]
  @usableFromInline
  internal static let U2: [Swift.UInt32]
  @usableFromInline
  internal static let U3: [Swift.UInt32]
  @usableFromInline
  internal static let U4: [Swift.UInt32]
  public init(key: Swift.Array<Swift.UInt8>, blockMode: any eMoneySDK.BlockMode, padding: eMoneySDK.Padding = .pkcs7) throws
  @inlinable final internal func encrypt(block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>? {
    if self.blockMode.options.contains(.paddingRequired) && block.count != AES.blockSize {
      return Array(block)
    }

    let rounds = self.variantNr
    let rk = self.expandedKey

    let b00 = UInt32(block[block.startIndex.advanced(by: 0)])
    let b01 = UInt32(block[block.startIndex.advanced(by: 1)]) << 8
    let b02 = UInt32(block[block.startIndex.advanced(by: 2)]) << 16
    let b03 = UInt32(block[block.startIndex.advanced(by: 3)]) << 24
    var b0 = b00 | b01 | b02 | b03

    let b10 = UInt32(block[block.startIndex.advanced(by: 4)])
    let b11 = UInt32(block[block.startIndex.advanced(by: 5)]) << 8
    let b12 = UInt32(block[block.startIndex.advanced(by: 6)]) << 16
    let b13 = UInt32(block[block.startIndex.advanced(by: 7)]) << 24
    var b1 = b10 | b11 | b12 | b13

    let b20 = UInt32(block[block.startIndex.advanced(by: 8)])
    let b21 = UInt32(block[block.startIndex.advanced(by: 9)]) << 8
    let b22 = UInt32(block[block.startIndex.advanced(by: 10)]) << 16
    let b23 = UInt32(block[block.startIndex.advanced(by: 11)]) << 24
    var b2 = b20 | b21 | b22 | b23

    let b30 = UInt32(block[block.startIndex.advanced(by: 12)])
    let b31 = UInt32(block[block.startIndex.advanced(by: 13)]) << 8
    let b32 = UInt32(block[block.startIndex.advanced(by: 14)]) << 16
    let b33 = UInt32(block[block.startIndex.advanced(by: 15)]) << 24
    var b3 = b30 | b31 | b32 | b33

    let tLength = 4
    let t = UnsafeMutablePointer<UInt32>.allocate(capacity: tLength)
    t.initialize(repeating: 0, count: tLength)
    defer {
      t.deinitialize(count: tLength)
      t.deallocate()
    }

    for r in 0..<rounds - 1 {
      t[0] = b0 ^ rk[r][0]
      t[1] = b1 ^ rk[r][1]
      t[2] = b2 ^ rk[r][2]
      t[3] = b3 ^ rk[r][3]

      let lb00 = AES.T0[Int(t[0] & 0xff)]
      let lb01 = AES.T1[Int((t[1] >> 8) & 0xff)]
      let lb02 = AES.T2[Int((t[2] >> 16) & 0xff)]
      let lb03 = AES.T3[Int(t[3] >> 24)]
      b0 = lb00 ^ lb01 ^ lb02 ^ lb03

      let lb10 = AES.T0[Int(t[1] & 0xff)]
      let lb11 = AES.T1[Int((t[2] >> 8) & 0xff)]
      let lb12 = AES.T2[Int((t[3] >> 16) & 0xff)]
      let lb13 = AES.T3[Int(t[0] >> 24)]
      b1 = lb10 ^ lb11 ^ lb12 ^ lb13

      let lb20 = AES.T0[Int(t[2] & 0xff)]
      let lb21 = AES.T1[Int((t[3] >> 8) & 0xff)]
      let lb22 = AES.T2[Int((t[0] >> 16) & 0xff)]
      let lb23 = AES.T3[Int(t[1] >> 24)]
      b2 = lb20 ^ lb21 ^ lb22 ^ lb23

      let lb30 = AES.T0[Int(t[3] & 0xff)]
      let lb31 = AES.T1[Int((t[0] >> 8) & 0xff)]
      let lb32 = AES.T2[Int((t[1] >> 16) & 0xff)]
      let lb33 = AES.T3[Int(t[2] >> 24)]
      b3 = lb30 ^ lb31 ^ lb32 ^ lb33
    }

    // last round
    let r = rounds - 1

    t[0] = b0 ^ rk[r][0]
    t[1] = b1 ^ rk[r][1]
    t[2] = b2 ^ rk[r][2]
    t[3] = b3 ^ rk[r][3]

    // rounds
    b0 = F1(t[0], t[1], t[2], t[3]) ^ rk[rounds][0]
    b1 = F1(t[1], t[2], t[3], t[0]) ^ rk[rounds][1]
    b2 = F1(t[2], t[3], t[0], t[1]) ^ rk[rounds][2]
    b3 = F1(t[3], t[0], t[1], t[2]) ^ rk[rounds][3]

    let encrypted: Array<UInt8> = [
      UInt8(b0 & 0xff), UInt8((b0 >> 8) & 0xff), UInt8((b0 >> 16) & 0xff), UInt8((b0 >> 24) & 0xff),
      UInt8(b1 & 0xff), UInt8((b1 >> 8) & 0xff), UInt8((b1 >> 16) & 0xff), UInt8((b1 >> 24) & 0xff),
      UInt8(b2 & 0xff), UInt8((b2 >> 8) & 0xff), UInt8((b2 >> 16) & 0xff), UInt8((b2 >> 24) & 0xff),
      UInt8(b3 & 0xff), UInt8((b3 >> 8) & 0xff), UInt8((b3 >> 16) & 0xff), UInt8((b3 >> 24) & 0xff)
    ]
    return encrypted
  }
  @usableFromInline
  final internal func decrypt(block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
  @objc deinit
}
extension eMoneySDK.AES {
  @usableFromInline
  @inline(__always) final internal func F1(_ x0: Swift.UInt32, _ x1: Swift.UInt32, _ x2: Swift.UInt32, _ x3: Swift.UInt32) -> Swift.UInt32
}
extension eMoneySDK.AES : eMoneySDK.Cipher {
  @inlinable final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    let blockSize = self.blockMode.customBlockSize ?? AES.blockSize
    let chunks = bytes.batched(by: blockSize)

    var oneTimeCryptor = try makeEncryptor()
    var out = Array<UInt8>(reserveCapacity: bytes.count)
    for chunk in chunks {
      out += try oneTimeCryptor.update(withBytes: chunk, isLast: false)
    }
    // Padding may be added at the very end
    out += try oneTimeCryptor.finish()

    if self.blockMode.options.contains(.paddingRequired) && (out.count % AES.blockSize != 0) {
      throw Error.dataPaddingRequired
    }

    return out
  }
  @inlinable final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    if self.blockMode.options.contains(.paddingRequired) && (bytes.count % AES.blockSize != 0) {
      throw Error.dataPaddingRequired
    }

    var oneTimeCryptor = try makeDecryptor()
    let chunks = bytes.batched(by: AES.blockSize)
    if chunks.isEmpty {
      throw Error.invalidData
    }

    var out = Array<UInt8>(reserveCapacity: bytes.count)

    var lastIdx = chunks.startIndex
    chunks.indices.formIndex(&lastIdx, offsetBy: chunks.count - 1)

    // To properly remove padding, `isLast` has to be known when called with the last chunk of ciphertext
    // Last chunk of ciphertext may contains padded data so next call to update(..) won't be able to remove it
    for idx in chunks.indices {
      out += try oneTimeCryptor.update(withBytes: chunks[idx], isLast: idx == lastIdx)
    }
    return out
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class LoginViewController : eMoneySDK.BaseViewController {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension Foundation.NSMutableAttributedString {
  public func setAsLink(textToFind: Swift.String, linkURL: Swift.String) -> Swift.Bool
}
final public class HMAC : eMoneySDK.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    case invalidInput
    public static func == (a: eMoneySDK.HMAC.Error, b: eMoneySDK.HMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant {
    case md5
    case sha1
    case sha2(eMoneySDK.SHA2.Variant)
    case sha3(eMoneySDK.SHA3.Variant)
    @available(*, deprecated, message: "Use sha2(variant) instead.")
    case sha256, sha384, sha512
  }
  public init(key: Swift.Array<Swift.UInt8>, variant: eMoneySDK.HMAC.Variant = .md5)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension Swift.UInt32 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt32(bytes[index.advanced(by: 0)]) << 24 : 0
    let val1 = count > 1 ? UInt32(bytes[index.advanced(by: 1)]) << 16 : 0
    let val2 = count > 2 ? UInt32(bytes[index.advanced(by: 2)]) << 8 : 0
    let val3 = count > 3 ? UInt32(bytes[index.advanced(by: 3)]) : 0

    self = val0 | val1 | val2 | val3
  }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @IBDesignable @_Concurrency.MainActor(unsafe) public class CustomSwitch : UIKit.UIControl {
  @_Concurrency.MainActor(unsafe) public var animationDelay: Swift.Double
  @_Concurrency.MainActor(unsafe) public var animationSpriteWithDamping: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) public var initialSpringVelocity: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) public var animationOptions: UIKit.UIView.AnimationOptions
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var isOn: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var animationDuration: Swift.Double
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var padding: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var onTintColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var offTintColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @IBInspectable @_Concurrency.MainActor(unsafe) @objc dynamic public var cornerRadius: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var thumbTintColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var thumbCornerRadius: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var thumbSize: CoreFoundation.CGSize {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var thumbImage: UIKit.UIImage? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public var onImage: UIKit.UIImage? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var offImage: UIKit.UIImage? {
    get
    set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var thumbShadowColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var thumbShadowOffset: CoreFoundation.CGSize {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var thumbShaddowRadius: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var thumbShaddowOppacity: Swift.Float {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public var labelOff: UIKit.UILabel
  @_Concurrency.MainActor(unsafe) public var labelOn: UIKit.UILabel
  @_Concurrency.MainActor(unsafe) public var areLabelsShown: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var thumbView: eMoneySDK.CustomThumbView
  @_Concurrency.MainActor(unsafe) public var onImageView: UIKit.UIImageView
  @_Concurrency.MainActor(unsafe) public var offImageView: UIKit.UIImageView
  @_Concurrency.MainActor(unsafe) public var onPoint: CoreFoundation.CGPoint
  @_Concurrency.MainActor(unsafe) public var offPoint: CoreFoundation.CGPoint
  @_Concurrency.MainActor(unsafe) public var isAnimating: Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
extension eMoneySDK.CustomSwitch {
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
}
extension eMoneySDK.CustomSwitch {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSubviews()
}
extension Swift.Array {
  @inlinable internal init(reserveCapacity: Swift.Int) {
    self = Array<Element>()
    self.reserveCapacity(reserveCapacity)
  }
  @inlinable internal var slice: Swift.ArraySlice<Element> {
    get {
    self[self.startIndex ..< self.endIndex]
  }
  }
  @inlinable internal subscript(safe index: Swift.Array<Element>.Index) -> Element? {
    get {
    return indices.contains(index) ? self[index] : nil
  }
  }
}
extension Swift.Array where Element == Swift.UInt8 {
  public init(hex: Swift.String)
  public func toHexString() -> Swift.String
}
extension Swift.Array where Element == Swift.UInt8 {
  @available(*, deprecated)
  public func chunks(size chunksize: Swift.Int) -> Swift.Array<Swift.Array<Element>>
  public func md5() -> [Element]
  public func sha1() -> [Element]
  public func sha224() -> [Element]
  public func sha256() -> [Element]
  public func sha384() -> [Element]
  public func sha512() -> [Element]
  public func sha2(_ variant: eMoneySDK.SHA2.Variant) -> [Element]
  public func sha3(_ variant: eMoneySDK.SHA3.Variant) -> [Element]
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.UInt16
  public func encrypt(cipher: any eMoneySDK.Cipher) throws -> [Element]
  public func decrypt(cipher: any eMoneySDK.Cipher) throws -> [Element]
  public func authenticate<A>(with authenticator: A) throws -> [Element] where A : eMoneySDK.Authenticator
}
extension eMoneySDK.CS.BigUInt {
  public mutating func multiply(byWord y: eMoneySDK.CS.BigUInt.Word)
  public func multiplied(byWord y: eMoneySDK.CS.BigUInt.Word) -> eMoneySDK.CS.BigUInt
  public mutating func multiplyAndAdd(_ x: eMoneySDK.CS.BigUInt, _ y: eMoneySDK.CS.BigUInt.Word, shiftedBy shift: Swift.Int = 0)
  public func multiplied(by y: eMoneySDK.CS.BigUInt) -> eMoneySDK.CS.BigUInt
  public static var directMultiplicationLimit: Swift.Int
  public static func * (x: eMoneySDK.CS.BigUInt, y: eMoneySDK.CS.BigUInt) -> eMoneySDK.CS.BigUInt
  public static func *= (a: inout eMoneySDK.CS.BigUInt, b: eMoneySDK.CS.BigUInt)
}
extension eMoneySDK.CS.BigInt {
  public static func * (a: eMoneySDK.CS.BigInt, b: eMoneySDK.CS.BigInt) -> eMoneySDK.CS.BigInt
  public static func *= (a: inout eMoneySDK.CS.BigInt, b: eMoneySDK.CS.BigInt)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class DefaultPinView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc override final public func awakeFromNib()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension eMoneySDK.DefaultPinView : eMoneySDK.PinContainer {
  @_Concurrency.MainActor(unsafe) final public func set(value: Swift.String?)
  @_Concurrency.MainActor(unsafe) final public func clear()
  @_Concurrency.MainActor(unsafe) final public func setupState(isActive: Swift.Bool, isError: Swift.Bool)
}
extension Swift.String {
  @inlinable public var bytes: Swift.Array<Swift.UInt8> {
    get {
    data(using: String.Encoding.utf8, allowLossyConversion: true)?.bytes ?? Array(utf8)
  }
  }
  @inlinable public func md5() -> Swift.String {
    self.bytes.md5().toHexString()
  }
  @inlinable public func sha1() -> Swift.String {
    self.bytes.sha1().toHexString()
  }
  @inlinable public func sha224() -> Swift.String {
    self.bytes.sha224().toHexString()
  }
  @inlinable public func sha256() -> Swift.String {
    self.bytes.sha256().toHexString()
  }
  @inlinable public func sha384() -> Swift.String {
    self.bytes.sha384().toHexString()
  }
  @inlinable public func sha512() -> Swift.String {
    self.bytes.sha512().toHexString()
  }
  @inlinable public func sha3(_ variant: eMoneySDK.SHA3.Variant) -> Swift.String {
    self.bytes.sha3(variant).toHexString()
  }
  @inlinable public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String {
    self.bytes.crc32(seed: seed, reflect: reflect).bytes().toHexString()
  }
  @inlinable public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String {
    self.bytes.crc32c(seed: seed, reflect: reflect).bytes().toHexString()
  }
  @inlinable public func crc16(seed: Swift.UInt16? = nil) -> Swift.String {
    self.bytes.crc16(seed: seed).bytes().toHexString()
  }
  @inlinable public func encrypt(cipher: any eMoneySDK.Cipher) throws -> Swift.String {
    try self.bytes.encrypt(cipher: cipher).toHexString()
  }
  @inlinable public func encryptToBase64(cipher: any eMoneySDK.Cipher) throws -> Swift.String {
    try self.bytes.encrypt(cipher: cipher).toBase64()
  }
  @inlinable public func authenticate<A>(with authenticator: A) throws -> Swift.String where A : eMoneySDK.Authenticator {
    try self.bytes.authenticate(with: authenticator).toHexString()
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class SplashViewController : eMoneySDK.BaseViewController {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) public func didInternetErrorTryAgainTapped()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@_inheritsConvenienceInitializers public class ThinWormHeadsDrawer : eMoneySDK.AdvancedPageControlDrawerParentWithIndicator, eMoneySDK.AdvancedPageControlDraw {
  public func draw(_ rect: CoreFoundation.CGRect)
  override public init(numberOfPages: Swift.Int? = super, height: CoreFoundation.CGFloat? = super, width: CoreFoundation.CGFloat? = super, space: CoreFoundation.CGFloat? = super, raduis: CoreFoundation.CGFloat? = super, currentItem: CoreFoundation.CGFloat? = super, indicatorColor: UIKit.UIColor? = super, dotsColor: UIKit.UIColor? = super, isBordered: Swift.Bool = super, borderColor: UIKit.UIColor = super, borderWidth: CoreFoundation.CGFloat = super, indicatorBorderColor: UIKit.UIColor = super, indicatorBorderWidth: CoreFoundation.CGFloat = super)
  @objc deinit
}
extension eMoneySDK.CS.BigUInt {
  public func isStrongProbablePrime(_ base: eMoneySDK.CS.BigUInt) -> Swift.Bool
  public func isPrime(rounds: Swift.Int = 10) -> Swift.Bool
}
extension eMoneySDK.CS.BigInt {
  public func isStrongProbablePrime(_ base: eMoneySDK.CS.BigInt) -> Swift.Bool
  public func isPrime(rounds: Swift.Int = 10) -> Swift.Bool
}
public enum PKCS7 {
}
@_hasMissingDesignatedInitializers final public class RSA {
  public enum Error : Swift.Error {
    case noPrivateKey
    case invalidInverseNotCoprimes
    case unsupportedRSAVersion
    case invalidPrimes
    case noPrimes
    case unableToCalculateCoefficient
    case invalidSignatureLength
    case invalidMessageLengthForSigning
    case invalidMessageLengthForEncryption
    case invalidDecryption
    public static func == (a: eMoneySDK.RSA.Error, b: eMoneySDK.RSA.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let n: eMoneySDK.BigUInteger
  final public let e: eMoneySDK.BigUInteger
  final public let d: eMoneySDK.BigUInteger?
  final public let keySize: Swift.Int
  final public let keySizeBytes: Swift.Int
  public init(n: eMoneySDK.BigUInteger, e: eMoneySDK.BigUInteger, d: eMoneySDK.BigUInteger? = nil)
  convenience public init(n: Swift.Array<Swift.UInt8>, e: Swift.Array<Swift.UInt8>, d: Swift.Array<Swift.UInt8>? = nil)
  convenience public init(keySize: Swift.Int) throws
  @objc deinit
}
extension eMoneySDK.RSA {
  convenience public init(rawRepresentation raw: Foundation.Data) throws
}
extension eMoneySDK.RSA {
  final public func externalRepresentation() throws -> Foundation.Data
  final public func publicKeyExternalRepresentation() throws -> Foundation.Data
}
extension eMoneySDK.CS.BigUInt {
  public static func generatePrime(_ width: Swift.Int) -> eMoneySDK.BigUInteger
}
extension eMoneySDK.RSA : Swift.CustomStringConvertible {
  final public var description: Swift.String {
    get
  }
}
@objc public protocol FloatingPanelControllerDelegate {
  @objc(floatingPanel:layoutForTraitCollection:) optional func floatingPanel(_ fpc: eMoneySDK.FloatingPanelController, layoutFor newCollection: UIKit.UITraitCollection) -> any eMoneySDK.FloatingPanelLayout
  @objc(floatingPanel:layoutForSize:) optional func floatingPanel(_ fpc: eMoneySDK.FloatingPanelController, layoutFor size: CoreFoundation.CGSize) -> any eMoneySDK.FloatingPanelLayout
  @objc(floatingPanel:animatorForPresentingToState:) optional func floatingPanel(_ fpc: eMoneySDK.FloatingPanelController, animatorForPresentingTo state: eMoneySDK.FloatingPanelState) -> UIKit.UIViewPropertyAnimator
  @objc(floatingPanel:animatorForDismissingWithVelocity:) optional func floatingPanel(_ fpc: eMoneySDK.FloatingPanelController, animatorForDismissingWith velocity: CoreFoundation.CGVector) -> UIKit.UIViewPropertyAnimator
  @objc optional func floatingPanelDidChangeState(_ fpc: eMoneySDK.FloatingPanelController)
  @objc optional func floatingPanelShouldBeginDragging(_ fpc: eMoneySDK.FloatingPanelController) -> Swift.Bool
  @objc optional func floatingPanelDidMove(_ fpc: eMoneySDK.FloatingPanelController)
  @objc optional func floatingPanelWillBeginDragging(_ fpc: eMoneySDK.FloatingPanelController)
  @objc optional func floatingPanelWillEndDragging(_ fpc: eMoneySDK.FloatingPanelController, withVelocity velocity: CoreFoundation.CGPoint, targetState: Swift.UnsafeMutablePointer<eMoneySDK.FloatingPanelState>)
  @objc optional func floatingPanelDidEndDragging(_ fpc: eMoneySDK.FloatingPanelController, willAttract attract: Swift.Bool)
  @objc optional func floatingPanelWillBeginAttracting(_ fpc: eMoneySDK.FloatingPanelController, to state: eMoneySDK.FloatingPanelState)
  @objc optional func floatingPanelDidEndAttracting(_ fpc: eMoneySDK.FloatingPanelController)
  @objc(floatingPanel:shouldRemoveAtLocation:withVelocity:) optional func floatingPanel(_ fpc: eMoneySDK.FloatingPanelController, shouldRemoveAt location: CoreFoundation.CGPoint, with velocity: CoreFoundation.CGVector) -> Swift.Bool
  @objc(floatingPanelWillRemove:) optional func floatingPanelWillRemove(_ fpc: eMoneySDK.FloatingPanelController)
  @objc optional func floatingPanelDidRemove(_ fpc: eMoneySDK.FloatingPanelController)
  @objc(floatingPanel:contentOffsetForPinningScrollView:) optional func floatingPanel(_ fpc: eMoneySDK.FloatingPanelController, contentOffsetForPinning trackingScrollView: UIKit.UIScrollView) -> CoreFoundation.CGPoint
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc @_Concurrency.MainActor(unsafe) open class FloatingPanelController : UIKit.UIViewController {
  @objc public enum ContentInsetAdjustmentBehavior : Swift.Int {
    case always
    case never
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public enum ContentMode : Swift.Int {
    case `static`
    case fitToBounds
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc @_Concurrency.MainActor(unsafe) weak public var delegate: (any eMoneySDK.FloatingPanelControllerDelegate)? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) public var surfaceView: eMoneySDK.SurfaceView! {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) public var backdropView: eMoneySDK.BackdropView! {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) weak public var trackingScrollView: UIKit.UIScrollView? {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) public var panGestureRecognizer: eMoneySDK.FloatingPanelPanGestureRecognizer {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) public var state: eMoneySDK.FloatingPanelState {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) public var isAttracting: Swift.Bool {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) public var layout: any eMoneySDK.FloatingPanelLayout {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) public var behavior: any eMoneySDK.FloatingPanelBehavior {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) public var adjustedContentInsets: UIKit.UIEdgeInsets {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) public var contentInsetAdjustmentBehavior: eMoneySDK.FloatingPanelController.ContentInsetAdjustmentBehavior
  @objc @_Concurrency.MainActor(unsafe) public var isRemovalInteractionEnabled: Swift.Bool {
    @objc(isRemovalInteractionEnabled) get
    @objc(setRemovalInteractionEnabled:) set
  }
  @objc @_Concurrency.MainActor(unsafe) public var contentViewController: UIKit.UIViewController? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public var nearbyState: eMoneySDK.FloatingPanelState {
    get
  }
  @objc @_Concurrency.MainActor(unsafe) public var contentMode: eMoneySDK.FloatingPanelController.ContentMode {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc @_Concurrency.MainActor(unsafe) public init(delegate: (any eMoneySDK.FloatingPanelControllerDelegate)? = nil)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func loadView()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewDidLayoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewWillTransition(to size: CoreFoundation.CGSize, with coordinator: any UIKit.UIViewControllerTransitionCoordinator)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func willTransition(to newCollection: UIKit.UITraitCollection, with coordinator: any UIKit.UIViewControllerTransitionCoordinator)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewWillDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var childForStatusBarStyle: UIKit.UIViewController? {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var childForStatusBarHidden: UIKit.UIViewController? {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var childForScreenEdgesDeferringSystemGestures: UIKit.UIViewController? {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var childForHomeIndicatorAutoHidden: UIKit.UIViewController? {
    @objc get
  }
  @objc(show:completion:) @_Concurrency.MainActor(unsafe) public func show(animated: Swift.Bool = false, completion: (() -> Swift.Void)? = nil)
  @objc(hide:completion:) @_Concurrency.MainActor(unsafe) public func hide(animated: Swift.Bool = false, completion: (() -> Swift.Void)? = nil)
  @objc(addPanelToParent:at:animated:completion:) @_Concurrency.MainActor(unsafe) public func addPanel(toParent parent: UIKit.UIViewController, at viewIndex: Swift.Int = -1, animated: Swift.Bool = false, completion: (() -> Swift.Void)? = nil)
  @objc(removePanelFromParent:completion:) @_Concurrency.MainActor(unsafe) public func removePanelFromParent(animated: Swift.Bool, completion: (() -> Swift.Void)? = nil)
  @objc(moveToState:animated:completion:) @_Concurrency.MainActor(unsafe) public func move(to: eMoneySDK.FloatingPanelState, animated: Swift.Bool, completion: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) public func set(contentViewController: UIKit.UIViewController?)
  @objc(trackScrollView:) @_Concurrency.MainActor(unsafe) public func track(scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) public func followScrollViewBouncing()
  @objc(untrackScrollView:) @_Concurrency.MainActor(unsafe) public func untrack(scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func accessibilityPerformEscape() -> Swift.Bool
  @objc @_Concurrency.MainActor(unsafe) public func invalidateLayout()
  @objc @_Concurrency.MainActor(unsafe) public func surfaceLocation(for state: eMoneySDK.FloatingPanelState) -> CoreFoundation.CGPoint
  @objc @_Concurrency.MainActor(unsafe) public var surfaceLocation: CoreFoundation.CGPoint {
    @objc get
    @objc set
  }
  @objc deinit
}
extension UIKit.UIViewController {
  @objc @_Concurrency.MainActor(unsafe) dynamic public func fp_original_dismiss(animated flag: Swift.Bool, completion: (() -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func fp_dismiss(animated flag: Swift.Bool, completion: (() -> Swift.Void)? = nil)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class ToolTipVC : UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) public func showToolTip(onItem viewItem: UIKit.UIView, cmView: UIKit.UIView, arrowDirection: UIKit.UIPopoverArrowDirection = .any, viewSize: CoreFoundation.CGSize = CGSize(width: CGFloat(0), height: CGFloat(0)))
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension eMoneySDK.ToolTipVC : UIKit.UIPopoverPresentationControllerDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func adaptivePresentationStyle(for controller: UIKit.UIPresentationController) -> UIKit.UIModalPresentationStyle
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor(unsafe) public class PrimaryButton : UIKit.UIButton {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var isEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor(unsafe) public class BaseButton : UIKit.UIButton {
  @_Concurrency.MainActor(unsafe) convenience public init(frameRect: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func prepareForInterfaceBuilder()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func awakeFromNib()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSubviews()
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOSApplicationExtension, unavailable)
@objc @_Concurrency.MainActor(unsafe) open class IQToolbar : UIKit.UIToolbar, UIKit.UIInputViewAudioFeedback {
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc @_Concurrency.MainActor(unsafe) open var previousBarButton: eMoneySDK.IQBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) open var nextBarButton: eMoneySDK.IQBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) open var titleBarButton: eMoneySDK.IQTitleBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) open var doneBarButton: eMoneySDK.IQBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) open var fixedSpaceBarButton: eMoneySDK.IQBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func sizeThatFits(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var tintColor: UIKit.UIColor! {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc open var enableInputClicksWhenVisible: Swift.Bool {
    @objc get
  }
  @objc deinit
}
public class EWalletTheme {
  public func setContentTheme(_ contentTheme: eMoneySDK.EContentTheme) -> eMoneySDK.EWalletTheme
  public func setStatusTheme(_ statusTheme: eMoneySDK.EStatusTheme) -> eMoneySDK.EWalletTheme
  public func setBackgroundColor(_ color: UIKit.UIColor) -> eMoneySDK.EWalletTheme
  public func setEditTextTheme(editTextTheme: eMoneySDK.EWalletEditTextTheme) -> eMoneySDK.EWalletTheme
  public func setToolbarTheme(_ theme: eMoneySDK.EWalletToolbarTheme) -> eMoneySDK.EWalletTheme
  public func setPrimaryButtonTheme(_ primaryButtonTheme: eMoneySDK.EWalletButtonTheme) -> eMoneySDK.EWalletTheme
  public func setSegmentBarTheme(_ segmentBarTheme: eMoneySDK.EWalletSegmentBarTheme) -> eMoneySDK.EWalletTheme
  public func setActivityIndicatorColor(_ color: UIKit.UIColor) -> eMoneySDK.EWalletTheme
  public func setListBackgroundColor(_ color: UIKit.UIColor) -> eMoneySDK.EWalletTheme
  public func setVisibilityToggleTextColor(_ color: UIKit.UIColor) -> eMoneySDK.EWalletTheme
  public init()
  @objc deinit
}
public struct EContentTheme {
  public init(headingColor: UIKit.UIColor?, notesColor: UIKit.UIColor?)
}
public struct EStatusTheme {
  public init(errorTextColor: UIKit.UIColor?, errorIconColor: UIKit.UIColor?, successColor: UIKit.UIColor?, warningColor: UIKit.UIColor? = nil)
}
public struct EWalletButtonTheme {
  public init(backgroundColor: (primary: UIKit.UIColor, secondary: UIKit.UIColor), textColor: UIKit.UIColor, font: UIKit.UIFont? = nil)
}
public struct EWalletEditTextTheme {
  public init(activeTextColor: UIKit.UIColor, inActiveTextColor: UIKit.UIColor, activeBorderColor: UIKit.UIColor, inActiveBorderColor: UIKit.UIColor, hintColor: UIKit.UIColor, separatorColor: UIKit.UIColor)
}
public struct EWalletToolbarTheme {
  public init(handlerColor: UIKit.UIColor, primaryTitleColor: UIKit.UIColor, secondaryTitleColor: UIKit.UIColor)
}
public struct EWalletSegmentBarTheme {
  public init(selectedColor: UIKit.UIColor, unSelectedColor: UIKit.UIColor)
}
final public class Poly1305 : eMoneySDK.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    public static func == (a: eMoneySDK.Poly1305.Error, b: eMoneySDK.Poly1305.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
public enum SDKLanguage {
  case arabic
  case english
  public static func == (a: eMoneySDK.SDKLanguage, b: eMoneySDK.SDKLanguage) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum Environment : Swift.String {
  case staging
  case production
  case preprod
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct EWalletConfiguration {
  public init(partnerName: Swift.String, partenerUserId: Swift.Int?, clientId: Swift.String, environment: eMoneySDK.Environment, theme: eMoneySDK.EWalletTheme?)
}
public enum EWalletErrorCode : Swift.String {
  case ERROR
  case GENERAL_ERROR
  case NO_DATA
  case NETWORK_ERROR
  case SESSION_EXPIRED
  case AML_FAILURE
  case BLOCKED_ACCOUNT
  case SUSPENDED_ACCOUNT
  case DEVICE_CHANGE
  case LIMITED
  case LOCKED
  case ONBOARDING_ALREADY_REGISTERED
  case ONBOARDING_REGISTERED_RESET_PIN
  case INVALID_MISDIN
  case ROLE_ACCESS_NOT_GRANTED
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers public class DropDrawer : eMoneySDK.AdvancedPageControlDrawerParentWithIndicator, eMoneySDK.AdvancedPageControlDraw {
  public func draw(_ rect: CoreFoundation.CGRect)
  override public init(numberOfPages: Swift.Int? = super, height: CoreFoundation.CGFloat? = super, width: CoreFoundation.CGFloat? = super, space: CoreFoundation.CGFloat? = super, raduis: CoreFoundation.CGFloat? = super, currentItem: CoreFoundation.CGFloat? = super, indicatorColor: UIKit.UIColor? = super, dotsColor: UIKit.UIColor? = super, isBordered: Swift.Bool = super, borderColor: UIKit.UIColor = super, borderWidth: CoreFoundation.CGFloat = super, indicatorBorderColor: UIKit.UIColor = super, indicatorBorderWidth: CoreFoundation.CGFloat = super)
  @objc deinit
}
extension eMoneySDK.CS.BigUInt {
  public static func >>= <Other>(lhs: inout eMoneySDK.CS.BigUInt, rhs: Other) where Other : Swift.BinaryInteger
  public static func <<= <Other>(lhs: inout eMoneySDK.CS.BigUInt, rhs: Other) where Other : Swift.BinaryInteger
  public static func >> <Other>(lhs: eMoneySDK.CS.BigUInt, rhs: Other) -> eMoneySDK.CS.BigUInt where Other : Swift.BinaryInteger
  public static func << <Other>(lhs: eMoneySDK.CS.BigUInt, rhs: Other) -> eMoneySDK.CS.BigUInt where Other : Swift.BinaryInteger
}
extension eMoneySDK.CS.BigInt {
  public static func &<< (left: eMoneySDK.CS.BigInt, right: eMoneySDK.CS.BigInt) -> eMoneySDK.CS.BigInt
  public static func &<<= (left: inout eMoneySDK.CS.BigInt, right: eMoneySDK.CS.BigInt)
  public static func &>> (left: eMoneySDK.CS.BigInt, right: eMoneySDK.CS.BigInt) -> eMoneySDK.CS.BigInt
  public static func &>>= (left: inout eMoneySDK.CS.BigInt, right: eMoneySDK.CS.BigInt)
  public static func << <Other>(lhs: eMoneySDK.CS.BigInt, rhs: Other) -> eMoneySDK.CS.BigInt where Other : Swift.BinaryInteger
  public static func <<= <Other>(lhs: inout eMoneySDK.CS.BigInt, rhs: Other) where Other : Swift.BinaryInteger
  public static func >> <Other>(lhs: eMoneySDK.CS.BigInt, rhs: Other) -> eMoneySDK.CS.BigInt where Other : Swift.BinaryInteger
  public static func >>= <Other>(lhs: inout eMoneySDK.CS.BigInt, rhs: Other) where Other : Swift.BinaryInteger
}
@_inheritsConvenienceInitializers public class ScrollingDrawer : eMoneySDK.AdvancedPageControlDrawerParentWithIndicator, eMoneySDK.AdvancedPageControlDraw {
  public func draw(_ rect: CoreFoundation.CGRect)
  override public init(numberOfPages: Swift.Int? = super, height: CoreFoundation.CGFloat? = super, width: CoreFoundation.CGFloat? = super, space: CoreFoundation.CGFloat? = super, raduis: CoreFoundation.CGFloat? = super, currentItem: CoreFoundation.CGFloat? = super, indicatorColor: UIKit.UIColor? = super, dotsColor: UIKit.UIColor? = super, isBordered: Swift.Bool = super, borderColor: UIKit.UIColor = super, borderWidth: CoreFoundation.CGFloat = super, indicatorBorderColor: UIKit.UIColor = super, indicatorBorderWidth: CoreFoundation.CGFloat = super)
  @objc deinit
}
extension Swift.UInt64 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt64(bytes[index.advanced(by: 0)]) << 56 : 0
    let val1 = count > 1 ? UInt64(bytes[index.advanced(by: 1)]) << 48 : 0
    let val2 = count > 2 ? UInt64(bytes[index.advanced(by: 2)]) << 40 : 0
    let val3 = count > 3 ? UInt64(bytes[index.advanced(by: 3)]) << 32 : 0
    let val4 = count > 4 ? UInt64(bytes[index.advanced(by: 4)]) << 24 : 0
    let val5 = count > 5 ? UInt64(bytes[index.advanced(by: 5)]) << 16 : 0
    let val6 = count > 6 ? UInt64(bytes[index.advanced(by: 6)]) << 8 : 0
    let val7 = count > 7 ? UInt64(bytes[index.advanced(by: 7)]) : 0

    self = val0 | val1 | val2 | val3 | val4 | val5 | val6 | val7
  }
}
open class IconWithLabelSegment : eMoneySDK.BetterSegmentedControlSegment {
  public var icon: UIKit.UIImage
  public var iconSize: CoreFoundation.CGSize
  final public let text: Swift.String?
  public var normalIconTintColor: UIKit.UIColor
  final public let normalFont: UIKit.UIFont
  final public let normalTextColor: UIKit.UIColor
  public var normalBackgroundColor: UIKit.UIColor
  public var selectedIconTintColor: UIKit.UIColor
  final public let selectedFont: UIKit.UIFont
  final public let selectedTextColor: UIKit.UIColor
  public var selectedBackgroundColor: UIKit.UIColor
  public init(icon: UIKit.UIImage, text: Swift.String? = nil, iconSize: CoreFoundation.CGSize, numberOfLines: Swift.Int = 1, normalBackgroundColor: UIKit.UIColor? = nil, normalIconTintColor: UIKit.UIColor, normalFont: UIKit.UIFont? = nil, normalTextColor: UIKit.UIColor? = nil, selectedBackgroundColor: UIKit.UIColor? = nil, selectedIconTintColor: UIKit.UIColor, selectedFont: UIKit.UIFont? = nil, selectedTextColor: UIKit.UIColor? = nil, accessibilityIdentifier: Swift.String? = nil)
  public var intrinsicContentSize: CoreFoundation.CGSize? {
    get
  }
  public var normalView: UIKit.UIView {
    get
    set
  }
  public var selectedView: UIKit.UIView {
    get
    set
  }
  @objc deinit
}
extension eMoneySDK.IconWithLabelSegment {
  public class func segments(withIconsAndLabels iconsAndLabelS: [eMoneySDK.IconWithLabel], iconSize: CoreFoundation.CGSize, numberOfLines: Swift.Int = 1, normalBackgroundColor: UIKit.UIColor? = nil, normalIconTintColor: UIKit.UIColor, normalFont: UIKit.UIFont? = nil, normalTextColor: UIKit.UIColor? = nil, selectedBackgroundColor: UIKit.UIColor? = nil, selectedIconTintColor: UIKit.UIColor, selectedFont: UIKit.UIFont? = nil, selectedTextColor: UIKit.UIColor? = nil) -> [any eMoneySDK.BetterSegmentedControlSegment]
}
@usableFromInline
final internal class StreamEncryptor : eMoneySDK.Cryptor, eMoneySDK.Updatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal var worker: any eMoneySDK.CipherModeWorker
  @usableFromInline
  final internal let padding: eMoneySDK.Padding
  @usableFromInline
  final internal var lastBlockRemainder: Swift.Int
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: eMoneySDK.Padding, _ worker: any eMoneySDK.CipherModeWorker) throws
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8> {
    var accumulated = Array(bytes)
    if isLast {
      // CTR doesn't need padding. Really. Add padding to the last block if really want. but... don't.
      accumulated = self.padding.add(to: accumulated, blockSize: self.blockSize - self.lastBlockRemainder)
    }

    var encrypted = Array<UInt8>(reserveCapacity: bytes.count)
    for chunk in accumulated.batched(by: self.blockSize) {
      encrypted += self.worker.encrypt(block: chunk)
    }

    // omit unecessary calculation if not needed
    if self.padding != .noPadding {
      self.lastBlockRemainder = encrypted.count.quotientAndRemainder(dividingBy: self.blockSize).remainder
    }

    if var finalizingWorker = worker as? FinalizingEncryptModeWorker, isLast == true {
      encrypted = Array(try finalizingWorker.finalize(encrypt: encrypted.slice))
    }

    return encrypted
  }
  @usableFromInline
  final internal func seek(to: Swift.Int) throws
  @objc @usableFromInline
  deinit
}
public protocol BetterSegmentedControlSegment {
  var intrinsicContentSize: CoreFoundation.CGSize? { get }
  var normalView: UIKit.UIView { get }
  var selectedView: UIKit.UIView { get }
}
extension eMoneySDK.RSA : eMoneySDK.Signature {
  final public func sign(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func sign(_ bytes: Swift.Array<Swift.UInt8>, variant: eMoneySDK.RSA.SignatureVariant) throws -> Swift.Array<Swift.UInt8>
  final public func verify(signature: Swift.ArraySlice<Swift.UInt8>, for expectedData: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Bool
  final public func verify(signature: Swift.Array<Swift.UInt8>, for bytes: Swift.Array<Swift.UInt8>, variant: eMoneySDK.RSA.SignatureVariant) throws -> Swift.Bool
}
extension eMoneySDK.RSA {
  public enum SignatureVariant {
    case raw
    case message_pkcs1v15_MD5
    case message_pkcs1v15_SHA1
    case message_pkcs1v15_SHA224
    case message_pkcs1v15_SHA256
    case message_pkcs1v15_SHA384
    case message_pkcs1v15_SHA512
    case message_pkcs1v15_SHA512_224
    case message_pkcs1v15_SHA512_256
    case digest_pkcs1v15_RAW
    case digest_pkcs1v15_MD5
    case digest_pkcs1v15_SHA1
    case digest_pkcs1v15_SHA224
    case digest_pkcs1v15_SHA256
    case digest_pkcs1v15_SHA384
    case digest_pkcs1v15_SHA512
    case digest_pkcs1v15_SHA512_224
    case digest_pkcs1v15_SHA512_256
    public static func == (a: eMoneySDK.RSA.SignatureVariant, b: eMoneySDK.RSA.SignatureVariant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
final public class OCB : eMoneySDK.BlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: eMoneySDK.OCB.Mode, b: eMoneySDK.OCB.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: eMoneySDK.BlockModeOption
  public enum Error : Swift.Error {
    case invalidNonce
    case fail
    public static func == (a: eMoneySDK.OCB.Error, b: eMoneySDK.OCB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let customBlockSize: Swift.Int?
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(nonce N: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: eMoneySDK.OCB.Mode = .detached)
  @inlinable convenience public init(nonce N: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: eMoneySDK.OCB.Mode = .detached) {
    self.init(nonce: N, additionalAuthenticatedData: additionalAuthenticatedData, tagLength: authenticationTag.count, mode: mode)
    self.authenticationTag = authenticationTag
  }
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping eMoneySDK.CipherOperationOnBlock, encryptionOperation: @escaping eMoneySDK.CipherOperationOnBlock) throws -> any eMoneySDK.CipherModeWorker
  @objc deinit
}
public typealias CipherOperationOnBlock = (_ block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
public protocol BlockMode {
  var options: eMoneySDK.BlockModeOption { get }
  @inlinable func worker(blockSize: Swift.Int, cipherOperation: @escaping eMoneySDK.CipherOperationOnBlock, encryptionOperation: @escaping eMoneySDK.CipherOperationOnBlock) throws -> any eMoneySDK.CipherModeWorker
  var customBlockSize: Swift.Int? { get }
}
extension eMoneySDK.CS {
  public struct BigInt : Swift.SignedInteger {
    public enum Sign {
      case plus
      case minus
      public static func == (a: eMoneySDK.CS.BigInt.Sign, b: eMoneySDK.CS.BigInt.Sign) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public typealias Magnitude = eMoneySDK.CS.BigUInt
    public typealias Word = eMoneySDK.CS.BigUInt.Word
    public static var isSigned: Swift.Bool {
      get
    }
    public var magnitude: eMoneySDK.CS.BigUInt
    public var sign: eMoneySDK.CS.BigInt.Sign
    public init(sign: eMoneySDK.CS.BigInt.Sign, magnitude: eMoneySDK.CS.BigUInt)
    public var isZero: Swift.Bool {
      get
    }
    public func signum() -> eMoneySDK.CS.BigInt
  }
}
final public class Scrypt {
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, dkLen: Swift.Int, N: Swift.Int, r: Swift.Int, p: Swift.Int) throws
  final public func calculate() throws -> [Swift.UInt8]
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class FloatingPanelPanGestureRecognizer : UIKit.UIPanGestureRecognizer {
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override weak final public var delegate: (any UIKit.UIGestureRecognizerDelegate)? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) weak final public var delegateProxy: (any UIKit.UIGestureRecognizerDelegate)? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(target: Any?, action: ObjectiveC.Selector?)
  @objc deinit
}
extension eMoneySDK.CS.BigUInt {
  public init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint
  public init<T>(_ source: T) where T : Swift.BinaryFloatingPoint
}
extension eMoneySDK.CS.BigInt {
  public init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint
  public init<T>(_ source: T) where T : Swift.BinaryFloatingPoint
}
extension Swift.BinaryFloatingPoint where Self.RawExponent : Swift.FixedWidthInteger, Self.RawSignificand : Swift.FixedWidthInteger {
  public init(_ value: eMoneySDK.CS.BigInt)
  public init(_ value: eMoneySDK.CS.BigUInt)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class OTPTextField : eMoneySDK.BaseInputView {
  @_Concurrency.MainActor(unsafe) final public var onBeginEditing: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var onTextChanged: ((Swift.String?) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var onEndEditing: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var onOTPEnter: ((Swift.String) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) @objc override final public var inputView: UIKit.UIView? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override final public var inputAccessoryView: UIKit.UIView? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override final public var canBecomeFirstResponder: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc override final public func awakeFromNib()
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @discardableResult
  @_Concurrency.MainActor(unsafe) @objc override final public func becomeFirstResponder() -> Swift.Bool
  @discardableResult
  @_Concurrency.MainActor(unsafe) @objc override final public func resignFirstResponder() -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override final public var hasText: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public func insertText(_ character: Swift.String)
  @_Concurrency.MainActor(unsafe) @objc override final public func deleteBackward()
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) final public func setConfiguration(_ configuration: eMoneySDK.OTPFieldConfiguration)
  @_Concurrency.MainActor(unsafe) final public func setEnabled(_ enabled: Swift.Bool)
  @_Concurrency.MainActor(unsafe) final public func setText(_ text: Swift.String)
  @_Concurrency.MainActor(unsafe) final public func setError()
  @_Concurrency.MainActor(unsafe) final public func removeError()
  @_Concurrency.MainActor(unsafe) final public func clear()
  @objc deinit
}
extension Swift.Array where Element == Swift.UInt8 {
  public func toBase64() -> Swift.String
  public init(base64: Swift.String)
}
public struct ECB : eMoneySDK.BlockMode {
  public let options: eMoneySDK.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init()
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping eMoneySDK.CipherOperationOnBlock, encryptionOperation: @escaping eMoneySDK.CipherOperationOnBlock) throws -> any eMoneySDK.CipherModeWorker
}
final public class SHA3 {
  final public let blockSize: Swift.Int
  final public let digestLength: Swift.Int
  final public let markByte: Swift.UInt8
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var accumulatedHash: Swift.Array<Swift.UInt64>
  public enum Variant {
    case sha224, sha256, sha384, sha512, keccak224, keccak256, keccak384, keccak512
    public var outputLength: Swift.Int {
      get
    }
    public static func == (a: eMoneySDK.SHA3.Variant, b: eMoneySDK.SHA3.Variant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(variant: eMoneySDK.SHA3.Variant)
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process(block chunk: Swift.ArraySlice<Swift.UInt64>, currentHash hh: inout Swift.Array<Swift.UInt64>)
  @objc deinit
}
extension eMoneySDK.SHA3 : eMoneySDK.Updatable {
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      // Add padding
      let markByteIndex = self.accumulated.count

      // We need to always pad the input. Even if the input is a multiple of blockSize.
      let r = self.blockSize * 8
      let q = (r / 8) - (accumulated.count % (r / 8))
      self.accumulated += Array<UInt8>(repeating: 0, count: q)

      self.accumulated[markByteIndex] |= self.markByte
      self.accumulated[self.accumulated.count - 1] |= 0x80
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: self.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= self.blockSize {
        self.process(block: chunk.toUInt64Array().slice, currentHash: &self.accumulatedHash)
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)

    // TODO: verify performance, reduce vs for..in
    let result = self.accumulatedHash.reduce(into: Array<UInt8>()) { (result, value) in
      result += value.bigEndian.bytes()
    }

    // reset hash value for instance
    if isLast {
      self.accumulatedHash = Array<UInt64>(repeating: 0, count: self.digestLength)
    }

    return Array(result[0..<self.digestLength])
  }
}
@available(iOSApplicationExtension, unavailable)
@objc final public class IQBarButtonItemConfiguration : ObjectiveC.NSObject {
  @objc public init(barButtonSystemItem: UIKit.UIBarButtonItem.SystemItem, action: ObjectiveC.Selector)
  @objc public init(image: UIKit.UIImage, action: ObjectiveC.Selector)
  @objc public init(title: Swift.String, action: ObjectiveC.Selector)
  final public let barButtonSystemItem: UIKit.UIBarButtonItem.SystemItem?
  @objc final public let image: UIKit.UIImage?
  @objc final public let title: Swift.String?
  @objc final public let action: ObjectiveC.Selector?
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
@objc extension UIKit.UIImage {
  @objc public static func keyboardLeftImage() -> UIKit.UIImage?
  @objc public static func keyboardRightImage() -> UIKit.UIImage?
  @objc public static func keyboardUpImage() -> UIKit.UIImage?
  @objc public static func keyboardDownImage() -> UIKit.UIImage?
  @objc public static func keyboardPreviousImage() -> UIKit.UIImage?
  @objc public static func keyboardNextImage() -> UIKit.UIImage?
}
@available(iOSApplicationExtension, unavailable)
@objc extension UIKit.UIView {
  @objc @_Concurrency.MainActor(unsafe) dynamic public var keyboardToolbar: eMoneySDK.IQToolbar {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var shouldHideToolbarPlaceholder: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var toolbarPlaceholder: Swift.String? {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var drawingToolbarPlaceholder: Swift.String? {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addKeyboardToolbarWithTarget(target: Swift.AnyObject?, titleText: Swift.String?, rightBarButtonConfiguration: eMoneySDK.IQBarButtonItemConfiguration?, previousBarButtonConfiguration: eMoneySDK.IQBarButtonItemConfiguration? = nil, nextBarButtonConfiguration: eMoneySDK.IQBarButtonItemConfiguration? = nil)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, action: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, action: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightButtonOnKeyboardWithImage(_ image: UIKit.UIImage, target: Swift.AnyObject?, action: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightButtonOnKeyboardWithImage(_ image: UIKit.UIImage, target: Swift.AnyObject?, action: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightButtonOnKeyboardWithText(_ text: Swift.String, target: Swift.AnyObject?, action: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightButtonOnKeyboardWithText(_ text: Swift.String, target: Swift.AnyObject?, action: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addCancelDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, cancelAction: ObjectiveC.Selector, doneAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightLeftOnKeyboardWithTarget(_ target: Swift.AnyObject?, leftButtonTitle: Swift.String, rightButtonTitle: Swift.String, leftButtonAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightLeftOnKeyboardWithTarget(_ target: Swift.AnyObject?, leftButtonImage: UIKit.UIImage, rightButtonImage: UIKit.UIImage, leftButtonAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addCancelDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, cancelAction: ObjectiveC.Selector, doneAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightLeftOnKeyboardWithTarget(_ target: Swift.AnyObject?, leftButtonTitle: Swift.String, rightButtonTitle: Swift.String, leftButtonAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightLeftOnKeyboardWithTarget(_ target: Swift.AnyObject?, leftButtonImage: UIKit.UIImage, rightButtonImage: UIKit.UIImage, leftButtonAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPreviousNextDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, doneAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPreviousNextRightOnKeyboardWithTarget(_ target: Swift.AnyObject?, rightButtonImage: UIKit.UIImage, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPreviousNextRightOnKeyboardWithTarget(_ target: Swift.AnyObject?, rightButtonTitle: Swift.String, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPreviousNextDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, doneAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPreviousNextRightOnKeyboardWithTarget(_ target: Swift.AnyObject?, rightButtonImage: UIKit.UIImage, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPreviousNextRightOnKeyboardWithTarget(_ target: Swift.AnyObject?, rightButtonTitle: Swift.String, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, titleText: Swift.String?)
}
prefix operator /
public typealias Index = Swift.Int
public typealias Closure = () -> Swift.Void
public typealias SelectionClosure = (eMoneySDK.Index, Swift.String) -> Swift.Void
public typealias MultiSelectionClosure = ([eMoneySDK.Index], [Swift.String]) -> Swift.Void
public typealias ConfigurationClosure = (eMoneySDK.Index, Swift.String) -> Swift.String
public typealias CellConfigurationClosure = (eMoneySDK.Index, Swift.String, eMoneySDK.DropDownCell) -> Swift.Void
@objc public protocol AnchorView {
  @objc var plainView: UIKit.UIView { get }
}
extension UIKit.UIView : eMoneySDK.AnchorView {
  @_Concurrency.MainActor(unsafe) @objc dynamic public var plainView: UIKit.UIView {
    @objc get
  }
}
extension UIKit.UIBarButtonItem : eMoneySDK.AnchorView {
  @_Concurrency.MainActor(unsafe) @objc dynamic public var plainView: UIKit.UIView {
    @objc get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class DropDown : UIKit.UIView {
  public enum DismissMode {
    case onTap
    case automatic
    case manual
    public static func == (a: eMoneySDK.DropDown.DismissMode, b: eMoneySDK.DropDown.DismissMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Direction {
    case any
    case top
    case bottom
    public static func == (a: eMoneySDK.DropDown.Direction, b: eMoneySDK.DropDown.Direction) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) weak public static var VisibleDropDown: eMoneySDK.DropDown?
  @_Concurrency.MainActor(unsafe) weak final public var anchorView: (any eMoneySDK.AnchorView)? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var direction: eMoneySDK.DropDown.Direction
  @_Concurrency.MainActor(unsafe) final public var topOffset: CoreFoundation.CGPoint {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var bottomOffset: CoreFoundation.CGPoint {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var offsetFromWindowBottom: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var width: CoreFoundation.CGFloat? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var arrowIndicationX: CoreFoundation.CGFloat? {
    get
    set
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic final public var cellHeight: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override final public var backgroundColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) final public var dimmedBackgroundColor: UIKit.UIColor {
    get
    set
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic final public var selectionBackgroundColor: UIKit.UIColor
  @objc @_Concurrency.MainActor(unsafe) dynamic final public var separatorColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic final public func setupCornerRadius(_ radius: CoreFoundation.CGFloat)
  @available(iOS 11.0, *)
  @objc @_Concurrency.MainActor(unsafe) dynamic final public func setupMaskedCorners(_ cornerMask: QuartzCore.CACornerMask)
  @objc @_Concurrency.MainActor(unsafe) dynamic final public var animationduration: Swift.Double
  @_Concurrency.MainActor(unsafe) public static var animationEntranceOptions: UIKit.UIView.AnimationOptions
  @_Concurrency.MainActor(unsafe) public static var animationExitOptions: UIKit.UIView.AnimationOptions
  @_Concurrency.MainActor(unsafe) final public var animationEntranceOptions: UIKit.UIView.AnimationOptions
  @_Concurrency.MainActor(unsafe) final public var animationExitOptions: UIKit.UIView.AnimationOptions
  @_Concurrency.MainActor(unsafe) final public var downScaleTransform: CoreFoundation.CGAffineTransform {
    get
    set
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic final public var textColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic final public var selectedTextColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic final public var textFont: UIKit.UIFont {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) final public var cellNib: UIKit.UINib {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var dataSource: [Swift.String] {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var localizationKeysDataSource: [Swift.String] {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var cellConfiguration: eMoneySDK.ConfigurationClosure? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var customCellConfiguration: eMoneySDK.CellConfigurationClosure? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var selectionAction: eMoneySDK.SelectionClosure?
  @_Concurrency.MainActor(unsafe) final public var multiSelectionAction: eMoneySDK.MultiSelectionClosure?
  @_Concurrency.MainActor(unsafe) final public var willShowAction: eMoneySDK.Closure?
  @_Concurrency.MainActor(unsafe) final public var cancelAction: eMoneySDK.Closure?
  @_Concurrency.MainActor(unsafe) final public var dismissMode: eMoneySDK.DropDown.DismissMode {
    get
    set
  }
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc convenience dynamic public init()
  @_Concurrency.MainActor(unsafe) convenience public init(anchorView: any eMoneySDK.AnchorView, selectionAction: eMoneySDK.SelectionClosure? = nil, dataSource: [Swift.String] = [], topOffset: CoreFoundation.CGPoint? = nil, bottomOffset: CoreFoundation.CGPoint? = nil, cellConfiguration: eMoneySDK.ConfigurationClosure? = nil, cancelAction: eMoneySDK.Closure? = nil)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
}
extension eMoneySDK.DropDown {
  @_Concurrency.MainActor(unsafe) @objc override final public func updateConstraints()
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
}
extension eMoneySDK.DropDown {
  @objc(show) @_Concurrency.MainActor(unsafe) final public func objc_show() -> Foundation.NSDictionary
  @discardableResult
  @_Concurrency.MainActor(unsafe) final public func show(onTopOf window: UIKit.UIWindow? = nil, beforeTransform transform: CoreFoundation.CGAffineTransform? = nil, anchorPoint: CoreFoundation.CGPoint? = nil) -> (canBeDisplayed: Swift.Bool, offscreenHeight: CoreFoundation.CGFloat?)
  @_Concurrency.MainActor(unsafe) @objc override final public func accessibilityPerformEscape() -> Swift.Bool
  @_Concurrency.MainActor(unsafe) final public func hide()
}
extension eMoneySDK.DropDown {
  @_Concurrency.MainActor(unsafe) final public func reloadAllComponents()
  @_Concurrency.MainActor(unsafe) final public func selectRow(at index: eMoneySDK.Index?, scrollPosition: UIKit.UITableView.ScrollPosition = .none)
  @_Concurrency.MainActor(unsafe) final public func selectRows(at indices: Swift.Set<eMoneySDK.Index>?)
  @_Concurrency.MainActor(unsafe) final public func deselectRow(at index: eMoneySDK.Index?)
  @_Concurrency.MainActor(unsafe) final public func deselectRows(at indices: Swift.Set<eMoneySDK.Index>?)
  @_Concurrency.MainActor(unsafe) final public var indexForSelectedRow: eMoneySDK.Index? {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var selectedItem: Swift.String? {
    get
  }
  @objc @_Concurrency.MainActor(unsafe) final public func selectRow(_ index: Swift.Int, scrollPosition: UIKit.UITableView.ScrollPosition = .none)
  @objc @_Concurrency.MainActor(unsafe) final public func clearSelection()
  @objc @_Concurrency.MainActor(unsafe) final public func deselectRow(_ index: Swift.Int)
  @objc @_Concurrency.MainActor(unsafe) final public var indexPathForSelectedRow: Foundation.NSIndexPath? {
    @objc get
  }
}
extension eMoneySDK.DropDown : UIKit.UITableViewDataSource, UIKit.UITableViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func tableView(_ tableView: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc final public func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
  @_Concurrency.MainActor(unsafe) @objc final public func tableView(_ tableView: UIKit.UITableView, willDisplay cell: UIKit.UITableViewCell, forRowAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc final public func tableView(_ tableView: UIKit.UITableView, didSelectRowAt indexPath: Foundation.IndexPath)
}
extension eMoneySDK.DropDown {
  @_Concurrency.MainActor(unsafe) @objc override final public func hitTest(_ point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
}
extension eMoneySDK.DropDown {
  @objc @_Concurrency.MainActor(unsafe) public static func startListeningToKeyboard()
}
@available(iOSApplicationExtension, unavailable)
@objc extension UIKit.UIViewController {
  @objc @_Concurrency.MainActor(unsafe) dynamic open func parentIQContainerViewController() -> UIKit.UIViewController?
  @objc @available(*, deprecated, message: "Due to change in core-logic of handling distance between textField and keyboard distance, this layout contraint tweak is no longer needed and things will just work out of the box regardless of constraint pinned with safeArea/layoutGuide/superview.")
  @IBOutlet @_Concurrency.MainActor(unsafe) dynamic public var IQLayoutGuideConstraint: UIKit.NSLayoutConstraint? {
    @objc get
    @objc set(newValue)
  }
}
public enum SignatureError : Swift.Error {
  case sign
  case verify
  public static func == (a: eMoneySDK.SignatureError, b: eMoneySDK.SignatureError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Signature : AnyObject {
  var keySize: Swift.Int { get }
  func sign(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func sign(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func verify(signature: Swift.ArraySlice<Swift.UInt8>, for expectedData: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Bool
  func verify(signature: Swift.Array<Swift.UInt8>, for expectedData: Swift.Array<Swift.UInt8>) throws -> Swift.Bool
}
extension eMoneySDK.Signature {
  public func sign(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func verify(signature: Swift.Array<Swift.UInt8>, for expectedData: Swift.Array<Swift.UInt8>) throws -> Swift.Bool
}
public class BlockDecryptor : eMoneySDK.Cryptor, eMoneySDK.Updatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal let padding: eMoneySDK.Padding
  @usableFromInline
  internal var worker: any eMoneySDK.CipherModeWorker
  @usableFromInline
  internal var accumulated: [Swift.UInt8]
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: eMoneySDK.Padding, _ worker: any eMoneySDK.CipherModeWorker) throws
  @inlinable public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    // If a worker (eg GCM) can combine ciphertext + tag
    // we need to remove tag from the ciphertext.
    if !isLast && self.accumulated.count < self.blockSize + self.worker.additionalBufferSize {
      return []
    }

    let accumulatedWithoutSuffix: Array<UInt8>
    if self.worker.additionalBufferSize > 0 {
      // FIXME: how slow is that?
      accumulatedWithoutSuffix = Array(self.accumulated.prefix(self.accumulated.count - self.worker.additionalBufferSize))
    } else {
      accumulatedWithoutSuffix = self.accumulated
    }

    var processedBytesCount = 0
    var plaintext = Array<UInt8>(reserveCapacity: accumulatedWithoutSuffix.count)
    // Processing in a block-size manner. It's good for block modes, but bad for stream modes.
    for var chunk in accumulatedWithoutSuffix.batched(by: self.blockSize) {
      if isLast || (accumulatedWithoutSuffix.count - processedBytesCount) >= blockSize {
        let isLastChunk = processedBytesCount + chunk.count == accumulatedWithoutSuffix.count

        if isLast, isLastChunk, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
          chunk = try finalizingWorker.willDecryptLast(bytes: chunk + accumulated.suffix(worker.additionalBufferSize)) // tag size
        }

        if !chunk.isEmpty {
          plaintext += worker.decrypt(block: chunk)
        }

        if isLast, isLastChunk, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
          plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
        }

        processedBytesCount += chunk.count
      }
    }
    accumulated.removeFirst(processedBytesCount) // super-slow

    if isLast {
      if accumulatedWithoutSuffix.isEmpty, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
        try finalizingWorker.willDecryptLast(bytes: self.accumulated.suffix(self.worker.additionalBufferSize))
        plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
      }
      plaintext = self.padding.remove(from: plaintext, blockSize: self.blockSize)
    }

    return plaintext
  }
  public func seek(to position: Swift.Int) throws
  @objc deinit
}
public struct OTPFieldConfiguration {
  public let adapter: any eMoneySDK.OTPTextFieldData
  public let keyboardType: UIKit.UIKeyboardType
  public let keyboardAppearance: UIKit.UIKeyboardAppearance
  public let autocorrectionType: UIKit.UITextAutocorrectionType
  public let allowedCharactersSet: Foundation.CharacterSet
  public init(adapter: any eMoneySDK.OTPTextFieldData, keyboardType: UIKit.UIKeyboardType = .numberPad, keyboardAppearance: UIKit.UIKeyboardAppearance = .light, autocorrectionType: UIKit.UITextAutocorrectionType = .no, allowedCharactersSet: Foundation.CharacterSet = .alphanumerics)
}
open class IconSegment : eMoneySDK.BetterSegmentedControlSegment {
  public var icon: UIKit.UIImage
  public var iconSize: CoreFoundation.CGSize
  public var normalIconTintColor: UIKit.UIColor
  public var normalBackgroundColor: UIKit.UIColor
  public var selectedIconTintColor: UIKit.UIColor
  public var selectedBackgroundColor: UIKit.UIColor
  public init(icon: UIKit.UIImage, iconSize: CoreFoundation.CGSize, normalBackgroundColor: UIKit.UIColor? = nil, normalIconTintColor: UIKit.UIColor, selectedBackgroundColor: UIKit.UIColor? = nil, selectedIconTintColor: UIKit.UIColor)
  public var intrinsicContentSize: CoreFoundation.CGSize? {
    get
  }
  public var normalView: UIKit.UIView {
    get
    set
  }
  public var selectedView: UIKit.UIView {
    get
    set
  }
  @objc deinit
}
extension eMoneySDK.IconSegment {
  public class func segments(withIcons icons: [UIKit.UIImage], iconSize: CoreFoundation.CGSize, normalBackgroundColor: UIKit.UIColor? = nil, normalIconTintColor: UIKit.UIColor, selectedBackgroundColor: UIKit.UIColor? = nil, selectedIconTintColor: UIKit.UIColor) -> [any eMoneySDK.BetterSegmentedControlSegment]
}
extension eMoneySDK.CS.BigUInt {
  public init?<S>(_ text: S, radix: Swift.Int = 10) where S : Swift.StringProtocol
}
extension eMoneySDK.CS.BigInt {
  public init?<S>(_ text: S, radix: Swift.Int = 10) where S : Swift.StringProtocol
}
extension Swift.String {
  public init(_ v: eMoneySDK.CS.BigUInt)
  public init(_ v: eMoneySDK.CS.BigUInt, radix: Swift.Int, uppercase: Swift.Bool = false)
  public init(_ value: eMoneySDK.CS.BigInt, radix: Swift.Int = 10, uppercase: Swift.Bool = false)
}
extension eMoneySDK.CS.BigUInt : Swift.ExpressibleByStringLiteral {
  public init(unicodeScalarLiteral value: Swift.UnicodeScalar)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public init(stringLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.UnicodeScalar
}
extension eMoneySDK.CS.BigInt : Swift.ExpressibleByStringLiteral {
  public init(unicodeScalarLiteral value: Swift.UnicodeScalar)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public init(stringLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.UnicodeScalar
}
extension eMoneySDK.CS.BigUInt : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension eMoneySDK.CS.BigInt : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension eMoneySDK.CS.BigUInt : Swift.CustomPlaygroundDisplayConvertible {
  public var playgroundDescription: Any {
    get
  }
}
extension eMoneySDK.CS.BigInt : Swift.CustomPlaygroundDisplayConvertible {
  public var playgroundDescription: Any {
    get
  }
}
extension eMoneySDK.CS.BigUInt {
  public static func + (a: eMoneySDK.CS.BigUInt, b: eMoneySDK.CS.BigUInt) -> eMoneySDK.CS.BigUInt
  public static func += (a: inout eMoneySDK.CS.BigUInt, b: eMoneySDK.CS.BigUInt)
}
extension eMoneySDK.CS.BigInt {
  public static func + (a: eMoneySDK.CS.BigInt, b: eMoneySDK.CS.BigInt) -> eMoneySDK.CS.BigInt
  public static func += (a: inout eMoneySDK.CS.BigInt, b: eMoneySDK.CS.BigInt)
}
extension eMoneySDK.PKCS5 {
  public struct PBKDF2 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: eMoneySDK.PKCS5.PBKDF2.Error, b: eMoneySDK.PKCS5.PBKDF2.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil, variant: eMoneySDK.HMAC.Variant = .sha2(.sha256)) throws
    public func calculate() throws -> Swift.Array<Swift.UInt8>
  }
}
extension eMoneySDK.ChaCha20 {
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
@_inheritsConvenienceInitializers public class SlideDrawer : eMoneySDK.AdvancedPageControlDrawerParentWithIndicator, eMoneySDK.AdvancedPageControlDraw {
  public func draw(_ rect: CoreFoundation.CGRect)
  override public init(numberOfPages: Swift.Int? = super, height: CoreFoundation.CGFloat? = super, width: CoreFoundation.CGFloat? = super, space: CoreFoundation.CGFloat? = super, raduis: CoreFoundation.CGFloat? = super, currentItem: CoreFoundation.CGFloat? = super, indicatorColor: UIKit.UIColor? = super, dotsColor: UIKit.UIColor? = super, isBordered: Swift.Bool = super, borderColor: UIKit.UIColor = super, borderWidth: CoreFoundation.CGFloat = super, indicatorBorderColor: UIKit.UIColor = super, indicatorBorderWidth: CoreFoundation.CGFloat = super)
  @objc deinit
}
final public class Rabbit {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    public static func == (a: eMoneySDK.Rabbit.Error, b: eMoneySDK.Rabbit.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let ivSize: Swift.Int
  public static let keySize: Swift.Int
  public static let blockSize: Swift.Int
  final public var keySize: Swift.Int {
    get
  }
  convenience public init(key: Swift.Array<Swift.UInt8>) throws
  public init(key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>?) throws
  @objc deinit
}
extension eMoneySDK.Rabbit : eMoneySDK.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
open class LabelSegment : eMoneySDK.BetterSegmentedControlSegment {
  final public let text: Swift.String?
  final public let normalFont: UIKit.UIFont
  final public let normalTextColor: UIKit.UIColor
  final public let normalBackgroundColor: UIKit.UIColor
  final public let selectedFont: UIKit.UIFont
  final public let selectedTextColor: UIKit.UIColor
  final public let selectedBackgroundColor: UIKit.UIColor
  public init(text: Swift.String? = nil, numberOfLines: Swift.Int = 1, normalBackgroundColor: UIKit.UIColor? = nil, normalFont: UIKit.UIFont? = nil, normalTextColor: UIKit.UIColor? = nil, selectedBackgroundColor: UIKit.UIColor? = nil, selectedFont: UIKit.UIFont? = nil, selectedTextColor: UIKit.UIColor? = nil, accessibilityIdentifier: Swift.String? = nil)
  public var intrinsicContentSize: CoreFoundation.CGSize? {
    get
  }
  public var normalView: UIKit.UIView {
    get
    set
  }
  public var selectedView: UIKit.UIView {
    get
    set
  }
  open func createLabel(withText text: Swift.String?, backgroundColor: UIKit.UIColor, font: UIKit.UIFont, textColor: UIKit.UIColor, accessibilityIdentifier: Swift.String?) -> UIKit.UILabel
  @objc deinit
}
extension eMoneySDK.LabelSegment {
  public class func segments(withTitles titles: [Swift.String], numberOfLines: Swift.Int = 1, normalBackgroundColor: UIKit.UIColor? = nil, normalFont: UIKit.UIFont? = nil, normalTextColor: UIKit.UIColor? = nil, selectedBackgroundColor: UIKit.UIColor? = nil, selectedFont: UIKit.UIFont? = nil, selectedTextColor: UIKit.UIColor? = nil) -> [any eMoneySDK.BetterSegmentedControlSegment]
}
@_hasMissingDesignatedInitializers final public class AEADChaCha20Poly1305 : eMoneySDK.AEAD {
  public static let kLen: Swift.Int
  public static var ivRange: Swift.Range<Swift.Int>
  public static func encrypt(_ plainText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>) throws -> (cipherText: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>)
  public static func decrypt(_ cipherText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>) throws -> (plainText: Swift.Array<Swift.UInt8>, success: Swift.Bool)
  @objc deinit
}
extension eMoneySDK.Blowfish {
  convenience public init(key: Swift.String, iv: Swift.String, padding: eMoneySDK.Padding = .pkcs7) throws
}
extension Foundation.Data {
  public func checksum() -> Swift.UInt16
  public func md5() -> Foundation.Data
  public func sha1() -> Foundation.Data
  public func sha224() -> Foundation.Data
  public func sha256() -> Foundation.Data
  public func sha384() -> Foundation.Data
  public func sha512() -> Foundation.Data
  public func sha3(_ variant: eMoneySDK.SHA3.Variant) -> Foundation.Data
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc16(seed: Swift.UInt16? = nil) -> Foundation.Data
  public func encrypt(cipher: any eMoneySDK.Cipher) throws -> Foundation.Data
  public func decrypt(cipher: any eMoneySDK.Cipher) throws -> Foundation.Data
  public func authenticate(with authenticator: any eMoneySDK.Authenticator) throws -> Foundation.Data
}
extension Foundation.Data {
  public init(hex: Swift.String)
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func toHexString() -> Swift.String
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor(unsafe) open class BetterSegmentedControl : UIKit.UIControl {
  @_Concurrency.MainActor(unsafe) public static let noSegment: Swift.Int
  @_Concurrency.MainActor(unsafe) public var index: Swift.Int {
    get
  }
  @_Concurrency.MainActor(unsafe) public var segments: [any eMoneySDK.BetterSegmentedControlSegment] {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public let indicatorView: eMoneySDK.BetterSegmentedControl.IndicatorView
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var alwaysAnnouncesValue: Swift.Bool
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var announcesValueImmediately: Swift.Bool
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var panningDisabled: Swift.Bool
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var cornerRadiusSegment: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var indicatorViewBackgroundColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var indicatorViewInset: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var indicatorViewBorderWidth: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var indicatorViewBorderColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var animationDuration: Swift.Double
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var animationSpringDamping: CoreFoundation.CGFloat
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var segmentPadding: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) public init(frame: CoreFoundation.CGRect, segments: [any eMoneySDK.BetterSegmentedControlSegment], index: Swift.Int = 0, options: [eMoneySDK.BetterSegmentedControl.Option]? = nil)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc convenience override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) public func setIndex(_ index: Swift.Int, animated: Swift.Bool = true, shouldSendValueChangedEvent: Swift.Bool = false)
  @_Concurrency.MainActor(unsafe) public func setOptions(_ options: [eMoneySDK.BetterSegmentedControl.Option])
  @objc deinit
}
extension eMoneySDK.BetterSegmentedControl : UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func gestureRecognizerShouldBegin(_ gestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
}
public func addColor(_ color1: UIKit.UIColor, with color2: UIKit.UIColor) -> UIKit.UIColor
public func multiplyColor(_ color: UIKit.UIColor, by multiplier: CoreFoundation.CGFloat) -> UIKit.UIColor
public func + (color1: UIKit.UIColor, color2: UIKit.UIColor) -> UIKit.UIColor
public func * (color: UIKit.UIColor, multiplier: Swift.Double) -> UIKit.UIColor
@objc public protocol FSPagerViewDataSource : ObjectiveC.NSObjectProtocol {
  @objc(numberOfItemsInPagerView:) func numberOfItems(in pagerView: eMoneySDK.FSPagerView) -> Swift.Int
  @objc(pagerView:cellForItemAtIndex:) func pagerView(_ pagerView: eMoneySDK.FSPagerView, cellForItemAt index: Swift.Int) -> eMoneySDK.FSPagerViewCell
}
@objc public protocol FSPagerViewDelegate : ObjectiveC.NSObjectProtocol {
  @objc(pagerView:shouldHighlightItemAtIndex:) optional func pagerView(_ pagerView: eMoneySDK.FSPagerView, shouldHighlightItemAt index: Swift.Int) -> Swift.Bool
  @objc(pagerView:didHighlightItemAtIndex:) optional func pagerView(_ pagerView: eMoneySDK.FSPagerView, didHighlightItemAt index: Swift.Int)
  @objc(pagerView:shouldSelectItemAtIndex:) optional func pagerView(_ pagerView: eMoneySDK.FSPagerView, shouldSelectItemAt index: Swift.Int) -> Swift.Bool
  @objc(pagerView:didSelectItemAtIndex:) optional func pagerView(_ pagerView: eMoneySDK.FSPagerView, didSelectItemAt index: Swift.Int)
  @objc(pagerView:willDisplayCell:forItemAtIndex:) optional func pagerView(_ pagerView: eMoneySDK.FSPagerView, willDisplay cell: eMoneySDK.FSPagerViewCell, forItemAt index: Swift.Int)
  @objc(pagerView:didEndDisplayingCell:forItemAtIndex:) optional func pagerView(_ pagerView: eMoneySDK.FSPagerView, didEndDisplaying cell: eMoneySDK.FSPagerViewCell, forItemAt index: Swift.Int)
  @objc(pagerViewWillBeginDragging:) optional func pagerViewWillBeginDragging(_ pagerView: eMoneySDK.FSPagerView)
  @objc(pagerViewWillEndDragging:targetIndex:) optional func pagerViewWillEndDragging(_ pagerView: eMoneySDK.FSPagerView, targetIndex: Swift.Int)
  @objc(pagerViewDidScroll:) optional func pagerViewDidScroll(_ pagerView: eMoneySDK.FSPagerView)
  @objc(pagerViewDidEndScrollAnimation:) optional func pagerViewDidEndScrollAnimation(_ pagerView: eMoneySDK.FSPagerView)
  @objc(pagerViewDidEndDecelerating:) optional func pagerViewDidEndDecelerating(_ pagerView: eMoneySDK.FSPagerView)
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor(unsafe) open class FSPagerView : UIKit.UIView, UIKit.UICollectionViewDataSource, UIKit.UICollectionViewDelegate {
  @objc @IBOutlet @_Concurrency.MainActor(unsafe) weak open var dataSource: (any eMoneySDK.FSPagerViewDataSource)?
  @objc @IBOutlet @_Concurrency.MainActor(unsafe) weak open var delegate: (any eMoneySDK.FSPagerViewDelegate)?
  @objc @_Concurrency.MainActor(unsafe) open var scrollDirection: eMoneySDK.FSPagerView.ScrollDirection {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var automaticSlidingInterval: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var interitemSpacing: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var itemSize: CoreFoundation.CGSize {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var isInfinite: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var decelerationDistance: Swift.UInt
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var isScrollEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var bounces: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var alwaysBounceHorizontal: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var alwaysBounceVertical: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var removesInfiniteLoopForSingleItem: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var backgroundView: UIKit.UIView? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) open var transformer: eMoneySDK.FSPagerViewTransformer? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) open var isTracking: Swift.Bool {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) open var scrollOffset: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) open var panGestureRecognizer: UIKit.UIPanGestureRecognizer {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic open var currentIndex: Swift.Int {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func willMove(toWindow newWindow: UIKit.UIWindow?)
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc public func numberOfSections(in collectionView: UIKit.UICollectionView) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc public func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
  @_Concurrency.MainActor(unsafe) @objc public func collectionView(_ collectionView: UIKit.UICollectionView, shouldHighlightItemAt indexPath: Foundation.IndexPath) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc public func collectionView(_ collectionView: UIKit.UICollectionView, didHighlightItemAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc public func collectionView(_ collectionView: UIKit.UICollectionView, shouldSelectItemAt indexPath: Foundation.IndexPath) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc public func collectionView(_ collectionView: UIKit.UICollectionView, didSelectItemAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc public func collectionView(_ collectionView: UIKit.UICollectionView, willDisplay cell: UIKit.UICollectionViewCell, forItemAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc public func collectionView(_ collectionView: UIKit.UICollectionView, didEndDisplaying cell: UIKit.UICollectionViewCell, forItemAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc public func scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc public func scrollViewWillBeginDragging(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc public func scrollViewWillEndDragging(_ scrollView: UIKit.UIScrollView, withVelocity velocity: CoreFoundation.CGPoint, targetContentOffset: Swift.UnsafeMutablePointer<CoreFoundation.CGPoint>)
  @_Concurrency.MainActor(unsafe) @objc public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc public func scrollViewDidEndScrollingAnimation(_ scrollView: UIKit.UIScrollView)
  @objc(registerClass:forCellWithReuseIdentifier:) @_Concurrency.MainActor(unsafe) open func register(_ cellClass: Swift.AnyClass?, forCellWithReuseIdentifier identifier: Swift.String)
  @objc(registerNib:forCellWithReuseIdentifier:) @_Concurrency.MainActor(unsafe) open func register(_ nib: UIKit.UINib?, forCellWithReuseIdentifier identifier: Swift.String)
  @objc(dequeueReusableCellWithReuseIdentifier:atIndex:) @_Concurrency.MainActor(unsafe) open func dequeueReusableCell(withReuseIdentifier identifier: Swift.String, at index: Swift.Int) -> eMoneySDK.FSPagerViewCell
  @objc(reloadData) @_Concurrency.MainActor(unsafe) open func reloadData()
  @objc(selectItemAtIndex:animated:) @_Concurrency.MainActor(unsafe) open func selectItem(at index: Swift.Int, animated: Swift.Bool)
  @objc(deselectItemAtIndex:animated:) @_Concurrency.MainActor(unsafe) open func deselectItem(at index: Swift.Int, animated: Swift.Bool)
  @objc(scrollToItemAtIndex:animated:) @_Concurrency.MainActor(unsafe) open func scrollToItem(at index: Swift.Int, animated: Swift.Bool)
  @objc(indexForCell:) @_Concurrency.MainActor(unsafe) open func index(for cell: eMoneySDK.FSPagerViewCell) -> Swift.Int
  @objc(cellForItemAtIndex:) @_Concurrency.MainActor(unsafe) open func cellForItem(at index: Swift.Int) -> eMoneySDK.FSPagerViewCell?
}
extension eMoneySDK.FSPagerView {
  @objc public enum ScrollDirection : Swift.Int {
    case horizontal
    case vertical
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) public static let automaticDistance: Swift.UInt
  @_Concurrency.MainActor(unsafe) public static let automaticSize: CoreFoundation.CGSize
}
extension UIKit.UITableView {
  @_Concurrency.MainActor(unsafe) public func registerCell(type: UIKit.UITableViewCell.Type, identifier: Swift.String? = nil)
  @_Concurrency.MainActor(unsafe) public func dequeueCell<T>(withType type: UIKit.UITableViewCell.Type) -> T? where T : UIKit.UITableViewCell
  @_Concurrency.MainActor(unsafe) public func dequeueCell<T>(withType type: UIKit.UITableViewCell.Type, for indexPath: Foundation.IndexPath) -> T? where T : UIKit.UITableViewCell
}
extension UIKit.UITableViewCell {
  @_Concurrency.MainActor(unsafe) public static var identifier: Swift.String {
    get
  }
}
extension eMoneySDK.BetterSegmentedControl {
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func prepareForInterfaceBuilder()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func awakeFromNib()
}
extension eMoneySDK.CS.BigUInt {
  public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public init<T>(_ source: T) where T : Swift.BinaryInteger
  public init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger
  public init<T>(clamping source: T) where T : Swift.BinaryInteger
}
extension eMoneySDK.CS.BigInt {
  public init()
  public init(_ integer: eMoneySDK.CS.BigUInt)
  public init<T>(_ source: T) where T : Swift.BinaryInteger
  public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public init<T>(clamping source: T) where T : Swift.BinaryInteger
  public init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger
}
extension eMoneySDK.CS.BigUInt : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.UInt64)
  public typealias IntegerLiteralType = Swift.UInt64
}
extension eMoneySDK.CS.BigInt : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.Int64)
  public typealias IntegerLiteralType = Swift.Int64
}
@available(iOSApplicationExtension, unavailable)
extension eMoneySDK.IQKeyboardManager {
  @objc final public var movedDistance: CoreFoundation.CGFloat {
    @objc get
  }
  @objc final public var movedDistanceChanged: ((CoreFoundation.CGFloat) -> Swift.Void)? {
    @objc get
    @objc set(newValue)
  }
}
@objc @IBDesignable @_Concurrency.MainActor(unsafe) open class TagView : UIKit.UIButton {
  @IBInspectable @_Concurrency.MainActor(unsafe) @objc dynamic open var cornerRadius: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @IBInspectable @_Concurrency.MainActor(unsafe) @objc dynamic open var borderWidth: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @IBInspectable @_Concurrency.MainActor(unsafe) @objc dynamic open var borderColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var textColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var selectedTextColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var titleLineBreakMode: UIKit.NSLineBreakMode {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var paddingY: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var paddingX: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var tagBackgroundColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var highlightedBackgroundColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var selectedBorderColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var selectedBackgroundColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var textFont: UIKit.UIFont {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isSelected: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var enableRemoveButton: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var removeButtonIconSize: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var removeIconLineWidth: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var removeIconLineColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) open var onTap: ((eMoneySDK.TagView) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) open var onLongPress: ((eMoneySDK.TagView) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public init(title: Swift.String)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @objc deinit
}
@usableFromInline
internal struct BatchedCollectionIndex<Base> where Base : Swift.Collection {
}
extension eMoneySDK.BatchedCollectionIndex : Swift.Comparable {
  @usableFromInline
  internal static func == <Base>(lhs: eMoneySDK.BatchedCollectionIndex<Base>, rhs: eMoneySDK.BatchedCollectionIndex<Base>) -> Swift.Bool where Base : Swift.Collection
  @usableFromInline
  internal static func < <Base>(lhs: eMoneySDK.BatchedCollectionIndex<Base>, rhs: eMoneySDK.BatchedCollectionIndex<Base>) -> Swift.Bool where Base : Swift.Collection
}
@usableFromInline
internal struct BatchedCollection<Base> : Swift.Collection where Base : Swift.Collection {
  @usableFromInline
  internal init(base: Base, size: Swift.Int)
  @usableFromInline
  internal typealias Index = eMoneySDK.BatchedCollectionIndex<Base>
  @usableFromInline
  internal var startIndex: eMoneySDK.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal var endIndex: eMoneySDK.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal func index(after idx: eMoneySDK.BatchedCollection<Base>.Index) -> eMoneySDK.BatchedCollection<Base>.Index
  @usableFromInline
  internal subscript(idx: eMoneySDK.BatchedCollection<Base>.Index) -> Base.SubSequence {
    get
  }
  @usableFromInline
  internal typealias Element = Base.SubSequence
  @usableFromInline
  internal typealias Indices = Swift.DefaultIndices<eMoneySDK.BatchedCollection<Base>>
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<eMoneySDK.BatchedCollection<Base>>
  @usableFromInline
  internal typealias SubSequence = Swift.Slice<eMoneySDK.BatchedCollection<Base>>
}
extension Swift.Collection {
  @inlinable internal func batched(by size: Swift.Int) -> eMoneySDK.BatchedCollection<Self> {
    BatchedCollection(base: self, size: size)
  }
}
public enum PKCS5 {
}
final public class SHA1 {
  @usableFromInline
  internal static let digestLength: Swift.Int
  @usableFromInline
  internal static let blockSize: Swift.Int
  @usableFromInline
  internal static let hashInitialValue: Swift.ContiguousArray<Swift.UInt32>
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var processedBytesTotalCount: Swift.Int
  @usableFromInline
  final internal var accumulatedHash: Swift.ContiguousArray<Swift.UInt32>
  public init()
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.ContiguousArray<Swift.UInt32>)
  @objc deinit
}
extension eMoneySDK.SHA1 : eMoneySDK.Updatable {
  @discardableResult
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      let lengthInBits = (processedBytesTotalCount + self.accumulated.count) * 8
      let lengthBytes = lengthInBits.bytes(totalBytes: 64 / 8) // A 64-bit representation of b

      // Step 1. Append padding
      bitPadding(to: &self.accumulated, blockSize: SHA1.blockSize, allowance: 64 / 8)

      // Step 2. Append Length a 64-bit representation of lengthInBits
      self.accumulated += lengthBytes
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: SHA1.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= SHA1.blockSize {
        self.process(block: chunk, currentHash: &self.accumulatedHash)
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)
    self.processedBytesTotalCount += processedBytes

    // output current hash
    var result = Array<UInt8>(repeating: 0, count: SHA1.digestLength)
    var pos = 0
    for idx in 0..<self.accumulatedHash.count {
      let h = self.accumulatedHash[idx]
      result[pos + 0] = UInt8((h >> 24) & 0xff)
      result[pos + 1] = UInt8((h >> 16) & 0xff)
      result[pos + 2] = UInt8((h >> 8) & 0xff)
      result[pos + 3] = UInt8(h & 0xff)
      pos += 4
    }

    // reset hash value for instance
    if isLast {
      self.accumulatedHash = SHA1.hashInitialValue
    }

    return result
  }
}
extension Swift.String {
  public func decryptBase64ToString(cipher: any eMoneySDK.Cipher) throws -> Swift.String
  public func decryptBase64(cipher: any eMoneySDK.Cipher) throws -> Swift.Array<Swift.UInt8>
}
final public class GCM : eMoneySDK.BlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: eMoneySDK.GCM.Mode, b: eMoneySDK.GCM.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: eMoneySDK.BlockModeOption
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case fail
    public static func == (a: eMoneySDK.GCM.Error, b: eMoneySDK.GCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let customBlockSize: Swift.Int?
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: eMoneySDK.GCM.Mode = .detached)
  convenience public init(iv: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: eMoneySDK.GCM.Mode = .detached)
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping eMoneySDK.CipherOperationOnBlock, encryptionOperation: @escaping eMoneySDK.CipherOperationOnBlock) throws -> any eMoneySDK.CipherModeWorker
  @objc deinit
}
public struct BlockModeOption : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  @usableFromInline
  internal static let none: eMoneySDK.BlockModeOption
  @usableFromInline
  internal static let initializationVectorRequired: eMoneySDK.BlockModeOption
  @usableFromInline
  internal static let paddingRequired: eMoneySDK.BlockModeOption
  @usableFromInline
  internal static let useEncryptToDecrypt: eMoneySDK.BlockModeOption
  public typealias ArrayLiteralElement = eMoneySDK.BlockModeOption
  public typealias Element = eMoneySDK.BlockModeOption
  public typealias RawValue = Swift.Int
}
extension UIKit.UICollectionView {
  @_Concurrency.MainActor(unsafe) public func registerCell(type: UIKit.UICollectionViewCell.Type, identifier: Swift.String? = nil)
  @_Concurrency.MainActor(unsafe) public func dequeueCell<T>(withType type: UIKit.UICollectionViewCell.Type, for indexPath: Foundation.IndexPath) -> T? where T : UIKit.UICollectionViewCell
}
extension UIKit.UICollectionReusableView {
  @_Concurrency.MainActor(unsafe) public static var identifier: Swift.String {
    get
  }
}
extension Swift.Collection where Self.Element == Swift.UInt8, Self.Index == Swift.Int {
  @inlinable internal func toUInt32Array() -> Swift.Array<Swift.UInt32> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 4)
    return Array<UInt32>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 4) {
        let val = UInt32(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
  @inlinable internal func toUInt64Array() -> Swift.Array<Swift.UInt64> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 8)
    return Array<UInt64>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 8) {
        let val = UInt64(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
}
@usableFromInline
internal func strideCount(from: Swift.Int, to: Swift.Int, by: Swift.Int) -> Swift.Int
extension eMoneySDK.CS.BigUInt : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension eMoneySDK.CS.BigInt : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct CardDetails : Swift.Hashable, Swift.Identifiable {
  public var number: Swift.String?
  public var name: Swift.String?
  public var expiryDate: Swift.String?
  public var cvcNumber: Swift.String?
  public var type: eMoneySDK.CardType
  public var industry: eMoneySDK.CardIndustry
  public init(numberWithDelimiters: Swift.String? = nil, name: Swift.String? = nil, expiryDate: Swift.String? = nil, cvcNumber: Swift.String? = nil)
  public var id: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: eMoneySDK.CardDetails, b: eMoneySDK.CardDetails) -> Swift.Bool
  public typealias ID = Swift.Int
  public var hashValue: Swift.Int {
    get
  }
}
public enum CardType : Swift.String, Swift.CaseIterable, Swift.Identifiable {
  case debit
  case credit
  case masterCard
  case visa
  case amex
  case discover
  case dinersClubOrCarteBlanche
  case unknown
  public init(number: Swift.String?)
  public var id: Swift.Int {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [eMoneySDK.CardType]
  public typealias ID = Swift.Int
  public typealias RawValue = Swift.String
  public static var allCases: [eMoneySDK.CardType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum CardIndustry : Swift.String, Swift.CaseIterable, Swift.Identifiable {
  case industry
  case airlines
  case airlinesFinancialAndFuture
  case travelAndEntertainment
  case bankingAndFinancial
  case merchandisingAndBanking
  case petroleum
  case healthcareAndTelecom
  case national
  case unknown
  public init(firstDigit: Swift.String.Element?)
  public var id: Swift.Int {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [eMoneySDK.CardIndustry]
  public typealias ID = Swift.Int
  public typealias RawValue = Swift.String
  public static var allCases: [eMoneySDK.CardIndustry] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
extension eMoneySDK.CS.BigInt : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension eMoneySDK.CS.BigUInt : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@objc public enum FloatingPanelReferenceEdge : Swift.Int {
  case top
  case left
  case bottom
  case right
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum FloatingPanelLayoutReferenceGuide : Swift.Int {
  case superview = 0
  case safeArea = 1
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum FloatingPanelLayoutContentBoundingGuide : Swift.Int {
  case none = 0
  case superview = 1
  case safeArea = 2
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension eMoneySDK.CS.BigUInt {
  prefix public static func ~ (a: eMoneySDK.CS.BigUInt) -> eMoneySDK.CS.BigUInt
  public static func |= (a: inout eMoneySDK.CS.BigUInt, b: eMoneySDK.CS.BigUInt)
  public static func &= (a: inout eMoneySDK.CS.BigUInt, b: eMoneySDK.CS.BigUInt)
  public static func ^= (a: inout eMoneySDK.CS.BigUInt, b: eMoneySDK.CS.BigUInt)
}
extension eMoneySDK.CS.BigInt {
  prefix public static func ~ (x: eMoneySDK.CS.BigInt) -> eMoneySDK.CS.BigInt
  public static func & (lhs: inout eMoneySDK.CS.BigInt, rhs: eMoneySDK.CS.BigInt) -> eMoneySDK.CS.BigInt
  public static func | (lhs: inout eMoneySDK.CS.BigInt, rhs: eMoneySDK.CS.BigInt) -> eMoneySDK.CS.BigInt
  public static func ^ (lhs: inout eMoneySDK.CS.BigInt, rhs: eMoneySDK.CS.BigInt) -> eMoneySDK.CS.BigInt
  public static func &= (lhs: inout eMoneySDK.CS.BigInt, rhs: eMoneySDK.CS.BigInt)
  public static func |= (lhs: inout eMoneySDK.CS.BigInt, rhs: eMoneySDK.CS.BigInt)
  public static func ^= (lhs: inout eMoneySDK.CS.BigInt, rhs: eMoneySDK.CS.BigInt)
}
@_specialize(exported: false, kind: full, where T == Swift.Int)
@_specialize(exported: false, kind: full, where T == Swift.UInt)
@_specialize(exported: false, kind: full, where T == Swift.UInt8)
@_specialize(exported: false, kind: full, where T == Swift.UInt16)
@_specialize(exported: false, kind: full, where T == Swift.UInt32)
@_specialize(exported: false, kind: full, where T == Swift.UInt64)
@inlinable internal func arrayOfBytes<T>(value: T, length totalBytes: Swift.Int = MemoryLayout<T>.size) -> Swift.Array<Swift.UInt8> where T : Swift.FixedWidthInteger {
  let valuePointer = UnsafeMutablePointer<T>.allocate(capacity: 1)
  valuePointer.pointee = value

  let bytesPointer = UnsafeMutablePointer<UInt8>(OpaquePointer(valuePointer))
  var bytes = Array<UInt8>(repeating: 0, count: totalBytes)
  for j in 0..<min(MemoryLayout<T>.size, totalBytes) {
    bytes[totalBytes - 1 - j] = (bytesPointer + j).pointee
  }

  valuePointer.deinitialize(count: 1)
  valuePointer.deallocate()

  return bytes
}
extension eMoneySDK.CS {
  public struct BigUInt : Swift.UnsignedInteger {
    public typealias Word = Swift.UInt
    public init()
    public init(words: [eMoneySDK.CS.BigUInt.Word])
    public typealias Magnitude = eMoneySDK.CS.BigUInt
  }
}
extension eMoneySDK.CS.BigUInt {
  public static var isSigned: Swift.Bool {
    get
  }
  public func signum() -> eMoneySDK.CS.BigUInt
}
public struct PCBC : eMoneySDK.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: eMoneySDK.PCBC.Error, b: eMoneySDK.PCBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: eMoneySDK.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping eMoneySDK.CipherOperationOnBlock, encryptionOperation: @escaping eMoneySDK.CipherOperationOnBlock) throws -> any eMoneySDK.CipherModeWorker
}
@objc public protocol TagListViewDelegate {
  @objc optional func tagPressed(_ title: Swift.String, tagView: eMoneySDK.TagView, sender: eMoneySDK.TagListView)
  @objc optional func tagRemoveButtonPressed(_ title: Swift.String, tagView: eMoneySDK.TagView, sender: eMoneySDK.TagListView)
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor(unsafe) open class TagListView : UIKit.UIView {
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var textColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var selectedTextColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var tagLineBreakMode: UIKit.NSLineBreakMode {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var tagBackgroundColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var tagHighlightedBackgroundColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var tagSelectedBackgroundColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @IBInspectable @_Concurrency.MainActor(unsafe) @objc dynamic open var cornerRadius: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @IBInspectable @_Concurrency.MainActor(unsafe) @objc dynamic open var borderWidth: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @IBInspectable @_Concurrency.MainActor(unsafe) @objc dynamic open var borderColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var selectedBorderColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var paddingY: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var paddingX: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var marginY: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var marginX: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var minWidth: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc public enum Alignment : Swift.Int {
    case left
    case center
    case right
    case leading
    case trailing
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var alignment: eMoneySDK.TagListView.Alignment {
    @objc get
    @objc set
  }
  @IBInspectable @_Concurrency.MainActor(unsafe) @objc dynamic open var shadowColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @IBInspectable @_Concurrency.MainActor(unsafe) @objc dynamic open var shadowRadius: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @IBInspectable @_Concurrency.MainActor(unsafe) @objc dynamic open var shadowOffset: CoreFoundation.CGSize {
    @objc get
    @objc set
  }
  @IBInspectable @_Concurrency.MainActor(unsafe) @objc dynamic open var shadowOpacity: Swift.Float {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var enableRemoveButton: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var removeButtonIconSize: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var removeIconLineWidth: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var removeIconLineColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic open var textFont: UIKit.UIFont {
    @objc get
    @objc set
  }
  @objc @IBOutlet @_Concurrency.MainActor(unsafe) weak open var delegate: (any eMoneySDK.TagListViewDelegate)?
  @_Concurrency.MainActor(unsafe) open var tagViews: [eMoneySDK.TagView] {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func prepareForInterfaceBuilder()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @discardableResult
  @_Concurrency.MainActor(unsafe) open func addTag(_ title: Swift.String) -> eMoneySDK.TagView
  @discardableResult
  @_Concurrency.MainActor(unsafe) open func addTags(_ titles: [Swift.String]) -> [eMoneySDK.TagView]
  @discardableResult
  @_Concurrency.MainActor(unsafe) open func addTagView(_ tagView: eMoneySDK.TagView) -> eMoneySDK.TagView
  @discardableResult
  @_Concurrency.MainActor(unsafe) open func addTagViews(_ tagViewList: [eMoneySDK.TagView]) -> [eMoneySDK.TagView]
  @discardableResult
  @_Concurrency.MainActor(unsafe) open func insertTag(_ title: Swift.String, at index: Swift.Int) -> eMoneySDK.TagView
  @discardableResult
  @_Concurrency.MainActor(unsafe) open func insertTagView(_ tagView: eMoneySDK.TagView, at index: Swift.Int) -> eMoneySDK.TagView
  @_Concurrency.MainActor(unsafe) open func setTitle(_ title: Swift.String, at index: Swift.Int)
  @_Concurrency.MainActor(unsafe) open func removeTag(_ title: Swift.String)
  @_Concurrency.MainActor(unsafe) open func removeTagView(_ tagView: eMoneySDK.TagView)
  @_Concurrency.MainActor(unsafe) open func removeAllTags()
  @_Concurrency.MainActor(unsafe) open func selectedTags() -> [eMoneySDK.TagView]
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
extension eMoneySDK.IQKeyboardManager {
  public typealias SizeBlock = (_ size: CoreFoundation.CGSize) -> Swift.Void
  @objc final public func registerKeyboardSizeChange(identifier: Swift.AnyHashable, sizeHandler: @escaping eMoneySDK.IQKeyboardManager.SizeBlock)
  @objc final public func unregisterKeyboardSizeChange(identifier: Swift.AnyHashable)
  @objc final public var keyboardShowing: Swift.Bool {
    @objc get
  }
  @objc final public var keyboardFrame: CoreFoundation.CGRect {
    @objc get
  }
}
final public class MD5 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension eMoneySDK.MD5 : eMoneySDK.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
extension eMoneySDK.RSA : eMoneySDK.Cipher {
  @inlinable final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    return try self.encrypt(Array<UInt8>(bytes), variant: .pksc1v15)
  }
  @inlinable final public func encrypt(_ bytes: Swift.Array<Swift.UInt8>, variant: eMoneySDK.RSA.RSAEncryptionVariant) throws -> Swift.Array<Swift.UInt8> {
    // Prepare the data for the specified variant
    let preparedData = try variant.prepare(bytes, blockSize: self.keySizeBytes)

    // Encrypt the prepared data
    return try variant.formatEncryptedBytes(self.encryptPreparedBytes(preparedData), blockSize: self.keySizeBytes)
  }
  @inlinable final internal func encryptPreparedBytes(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    // Calculate encrypted data
    return BigUInteger(Data(bytes)).power(self.e, modulus: self.n).serialize().bytes
  }
  @inlinable final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    return try self.decrypt(Array<UInt8>(bytes), variant: .pksc1v15)
  }
  @inlinable final public func decrypt(_ bytes: Swift.Array<Swift.UInt8>, variant: eMoneySDK.RSA.RSAEncryptionVariant) throws -> Swift.Array<Swift.UInt8> {
    // Decrypt the data
    let decrypted = try self.decryptPreparedBytes(bytes)

    // Remove padding / unstructure data and return the raw plaintext
    return variant.removePadding(decrypted, blockSize: self.keySizeBytes)
  }
  @inlinable final internal func decryptPreparedBytes(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    // Check for Private Exponent presence
    guard let d = d else { throw RSA.Error.noPrivateKey }

    // Calculate decrypted data
    return BigUInteger(Data(bytes)).power(d, modulus: self.n).serialize().bytes
  }
}
extension eMoneySDK.RSA {
  public enum RSAEncryptionVariant {
    case unsafe
    case raw
    case pksc1v15
    @inlinable internal func prepare(_ bytes: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) throws -> Swift.Array<Swift.UInt8> {
      switch self {
        case .unsafe:
          return bytes
        case .raw:
          // We need at least 11 bytes of padding in order to safely encrypt messages
          // - block types 1 and 2 have this minimum padding requirement, block type 0 isn't specified, but we enforce the minimum padding length here to be safe.
          guard blockSize >= bytes.count + 11 else { throw RSA.Error.invalidMessageLengthForEncryption }
          return Array(repeating: 0x00, count: blockSize - bytes.count) + bytes
        case .pksc1v15:
          // The `Security` framework refuses to encrypt a zero byte message using the pkcs1v15 padding scheme, so we do the same
          guard !bytes.isEmpty else { throw RSA.Error.invalidMessageLengthForEncryption }
          // We need at least 11 bytes of random padding in order to safely encrypt messages (RFC2313 Section 8.1 - Note 6)
          guard blockSize >= bytes.count + 11 else { throw RSA.Error.invalidMessageLengthForEncryption }
          return Padding.eme_pkcs1v15.add(to: bytes, blockSize: blockSize)
      @unknown default:
        assertionFailure()
        return [UInt8](repeating: UInt8.random(in: 0..<UInt8.max), count: bytes.count)
      }
    }
    @inlinable internal func formatEncryptedBytes(_ bytes: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8> {
      switch self {
        case .unsafe:
          return bytes
        case .raw, .pksc1v15:
          // Format the encrypted bytes before returning
          return Array<UInt8>(repeating: 0x00, count: blockSize - bytes.count) + bytes
      @unknown default:
        assertionFailure()
        return [UInt8](repeating: UInt8.random(in: 0..<UInt8.max), count: bytes.count)
      }
    }
    @inlinable internal func removePadding(_ bytes: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8> {
      switch self {
        case .unsafe:
          return bytes
        case .raw:
          return bytes
        case .pksc1v15:
          // Convert the Octet String into an Integer Primitive using the BigInteger `serialize` method
          // (this effectively just prefixes the data with a 0x00 byte indicating that its a positive integer)
          return Padding.eme_pkcs1v15.remove(from: [0x00] + bytes, blockSize: blockSize)
      @unknown default:
        assertionFailure()
        return [UInt8](repeating: UInt8.random(in: 0..<UInt8.max), count: bytes.count)
      }
    }
    public static func == (a: eMoneySDK.RSA.RSAEncryptionVariant, b: eMoneySDK.RSA.RSAEncryptionVariant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@_hasMissingDesignatedInitializers @objc(FloatingPanelBackdropView) @_Concurrency.MainActor(unsafe) public class BackdropView : UIKit.UIView {
  @objc @_Concurrency.MainActor(unsafe) public var dismissalTapGestureRecognizer: UIKit.UITapGestureRecognizer
  @objc deinit
}
@_inheritsConvenienceInitializers public class InfiniteScrollingDrawer : eMoneySDK.AdvancedPageControlDrawerParentWithIndicator, eMoneySDK.AdvancedPageControlDraw {
  public func draw(_ rect: CoreFoundation.CGRect)
  override public init(numberOfPages: Swift.Int? = super, height: CoreFoundation.CGFloat? = super, width: CoreFoundation.CGFloat? = super, space: CoreFoundation.CGFloat? = super, raduis: CoreFoundation.CGFloat? = super, currentItem: CoreFoundation.CGFloat? = super, indicatorColor: UIKit.UIColor? = super, dotsColor: UIKit.UIColor? = super, isBordered: Swift.Bool = super, borderColor: UIKit.UIColor = super, borderWidth: CoreFoundation.CGFloat = super, indicatorBorderColor: UIKit.UIColor = super, indicatorBorderWidth: CoreFoundation.CGFloat = super)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOSApplicationExtension, unavailable)
@objc final public class IQKeyboardManager : ObjectiveC.NSObject {
  @objc public static let shared: eMoneySDK.IQKeyboardManager
  @objc final public var enable: Swift.Bool {
    @objc get
    @objc set
  }
  @objc final public var keyboardDistanceFromTextField: CoreFoundation.CGFloat
  @objc final public var enableAutoToolbar: Swift.Bool {
    @objc get
    @objc set
  }
  @objc final public var toolbarManageBehaviour: eMoneySDK.IQAutoToolbarManageBehaviour
  @objc final public var shouldToolbarUsesTextFieldTintColor: Swift.Bool
  @objc final public var toolbarTintColor: UIKit.UIColor?
  @objc final public var toolbarBarTintColor: UIKit.UIColor?
  @objc final public var previousNextDisplayMode: eMoneySDK.IQPreviousNextDisplayMode
  @objc final public var toolbarPreviousBarButtonItemImage: UIKit.UIImage?
  @objc final public var toolbarNextBarButtonItemImage: UIKit.UIImage?
  @objc final public var toolbarDoneBarButtonItemImage: UIKit.UIImage?
  @objc final public var toolbarPreviousBarButtonItemText: Swift.String?
  @objc final public var toolbarPreviousBarButtonItemAccessibilityLabel: Swift.String?
  @objc final public var toolbarNextBarButtonItemText: Swift.String?
  @objc final public var toolbarNextBarButtonItemAccessibilityLabel: Swift.String?
  @objc final public var toolbarDoneBarButtonItemText: Swift.String?
  @objc final public var toolbarDoneBarButtonItemAccessibilityLabel: Swift.String?
  @objc final public var shouldShowToolbarPlaceholder: Swift.Bool
  @objc final public var placeholderFont: UIKit.UIFont?
  @objc final public var placeholderColor: UIKit.UIColor?
  @objc final public var placeholderButtonColor: UIKit.UIColor?
  @objc final public var overrideKeyboardAppearance: Swift.Bool
  @objc final public var keyboardAppearance: UIKit.UIKeyboardAppearance
  @objc final public var shouldResignOnTouchOutside: Swift.Bool {
    @objc get
    @objc set
  }
  @objc final public var resignFirstResponderGesture: UIKit.UITapGestureRecognizer {
    @objc get
    @objc set
  }
  @discardableResult
  @objc final public func resignFirstResponder() -> Swift.Bool
  @objc final public var shouldPlayInputClicks: Swift.Bool
  @objc final public var layoutIfNeededOnUpdate: Swift.Bool
  @objc final public var disabledDistanceHandlingClasses: [UIKit.UIViewController.Type]
  @objc final public var enabledDistanceHandlingClasses: [UIKit.UIViewController.Type]
  @objc final public var disabledToolbarClasses: [UIKit.UIViewController.Type]
  @objc final public var enabledToolbarClasses: [UIKit.UIViewController.Type]
  @objc final public var toolbarPreviousNextAllowedClasses: [UIKit.UIView.Type]
  @objc final public var disabledTouchResignedClasses: [UIKit.UIViewController.Type]
  @objc final public var enabledTouchResignedClasses: [UIKit.UIViewController.Type]
  @objc final public var touchResignedGestureIgnoreClasses: [UIKit.UIView.Type]
  @objc final public func registerTextFieldViewClass(_ aClass: UIKit.UIView.Type, didBeginEditingNotificationName: Swift.String, didEndEditingNotificationName: Swift.String)
  @objc final public func unregisterTextFieldViewClass(_ aClass: UIKit.UIView.Type, didBeginEditingNotificationName: Swift.String, didEndEditingNotificationName: Swift.String)
  @objc deinit
  @objc final public func reloadLayoutIfNeeded()
}
@available(iOSApplicationExtension, unavailable)
extension eMoneySDK.IQKeyboardManager : UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldReceive touch: UIKit.UITouch) -> Swift.Bool
}
extension eMoneySDK.HKDF.Error : Swift.Equatable {}
extension eMoneySDK.HKDF.Error : Swift.Hashable {}
extension eMoneySDK.CCM : eMoneySDK.BlockMode {}
extension eMoneySDK.CCM.Error : Swift.Equatable {}
extension eMoneySDK.CCM.Error : Swift.Hashable {}
extension eMoneySDK.CFB.Error : Swift.Equatable {}
extension eMoneySDK.CFB.Error : Swift.Hashable {}
extension eMoneySDK.CFB.SegmentSize : Swift.Equatable {}
extension eMoneySDK.CFB.SegmentSize : Swift.Hashable {}
extension eMoneySDK.CFB.SegmentSize : Swift.RawRepresentable {}
extension eMoneySDK.CMAC.Error : Swift.Equatable {}
extension eMoneySDK.CMAC.Error : Swift.Hashable {}
extension eMoneySDK.OFB.Error : Swift.Equatable {}
extension eMoneySDK.OFB.Error : Swift.Hashable {}
extension eMoneySDK.Blowfish.Error : Swift.Equatable {}
extension eMoneySDK.Blowfish.Error : Swift.Hashable {}
extension eMoneySDK.CTR : eMoneySDK.BlockMode {}
extension eMoneySDK.CTR.Error : Swift.Equatable {}
extension eMoneySDK.CTR.Error : Swift.Hashable {}
extension eMoneySDK.Bit : Swift.Equatable {}
extension eMoneySDK.Bit : Swift.Hashable {}
extension eMoneySDK.Bit : Swift.RawRepresentable {}
@available(iOSApplicationExtension, unavailable)
extension eMoneySDK.IQAutoToolbarManageBehaviour : Swift.Equatable {}
@available(iOSApplicationExtension, unavailable)
extension eMoneySDK.IQAutoToolbarManageBehaviour : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension eMoneySDK.IQAutoToolbarManageBehaviour : Swift.RawRepresentable {}
@available(iOSApplicationExtension, unavailable)
extension eMoneySDK.IQPreviousNextDisplayMode : Swift.Equatable {}
@available(iOSApplicationExtension, unavailable)
extension eMoneySDK.IQPreviousNextDisplayMode : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension eMoneySDK.IQPreviousNextDisplayMode : Swift.RawRepresentable {}
@available(iOSApplicationExtension, unavailable)
extension eMoneySDK.IQEnableMode : Swift.Equatable {}
@available(iOSApplicationExtension, unavailable)
extension eMoneySDK.IQEnableMode : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension eMoneySDK.IQEnableMode : Swift.RawRepresentable {}
extension eMoneySDK.ChaCha20.Error : Swift.Equatable {}
extension eMoneySDK.ChaCha20.Error : Swift.Hashable {}
extension eMoneySDK.CipherError : Swift.Equatable {}
extension eMoneySDK.CipherError : Swift.Hashable {}
extension eMoneySDK.FSPagerViewTransformerType : Swift.Equatable {}
extension eMoneySDK.FSPagerViewTransformerType : Swift.Hashable {}
extension eMoneySDK.FSPagerViewTransformerType : Swift.RawRepresentable {}
extension eMoneySDK.CBC.Error : Swift.Equatable {}
extension eMoneySDK.CBC.Error : Swift.Hashable {}
extension eMoneySDK.FontName : Swift.Equatable {}
extension eMoneySDK.FontName : Swift.Hashable {}
extension eMoneySDK.FontName : Swift.RawRepresentable {}
extension eMoneySDK.FontSize : Swift.Equatable {}
extension eMoneySDK.FontSize : Swift.Hashable {}
extension eMoneySDK.FontSize : Swift.RawRepresentable {}
extension eMoneySDK.FloatingPanelPosition : Swift.Equatable {}
extension eMoneySDK.FloatingPanelPosition : Swift.Hashable {}
extension eMoneySDK.FloatingPanelPosition : Swift.RawRepresentable {}
extension eMoneySDK.NVActivityIndicatorType : Swift.Equatable {}
extension eMoneySDK.NVActivityIndicatorType : Swift.Hashable {}
extension eMoneySDK.Padding : Swift.Equatable {}
extension eMoneySDK.Padding : Swift.Hashable {}
extension eMoneySDK.PKCS5.PBKDF1.Error : Swift.Equatable {}
extension eMoneySDK.PKCS5.PBKDF1.Error : Swift.Hashable {}
extension eMoneySDK.PKCS5.PBKDF1.Variant : Swift.Equatable {}
extension eMoneySDK.PKCS5.PBKDF1.Variant : Swift.Hashable {}
extension eMoneySDK.SHA2.Variant : Swift.Equatable {}
extension eMoneySDK.SHA2.Variant : Swift.Hashable {}
extension eMoneySDK.SHA2.Variant : Swift.Sendable {}
extension eMoneySDK.AES.Error : Swift.Equatable {}
extension eMoneySDK.AES.Error : Swift.Hashable {}
extension eMoneySDK.AES.Variant : Swift.Equatable {}
extension eMoneySDK.AES.Variant : Swift.Hashable {}
extension eMoneySDK.AES.Variant : Swift.RawRepresentable {}
extension eMoneySDK.HMAC.Error : Swift.Equatable {}
extension eMoneySDK.HMAC.Error : Swift.Hashable {}
extension eMoneySDK.RSA.Error : Swift.Equatable {}
extension eMoneySDK.RSA.Error : Swift.Hashable {}
extension eMoneySDK.FloatingPanelController.ContentInsetAdjustmentBehavior : Swift.Equatable {}
extension eMoneySDK.FloatingPanelController.ContentInsetAdjustmentBehavior : Swift.Hashable {}
extension eMoneySDK.FloatingPanelController.ContentInsetAdjustmentBehavior : Swift.RawRepresentable {}
extension eMoneySDK.FloatingPanelController.ContentMode : Swift.Equatable {}
extension eMoneySDK.FloatingPanelController.ContentMode : Swift.Hashable {}
extension eMoneySDK.FloatingPanelController.ContentMode : Swift.RawRepresentable {}
extension eMoneySDK.Poly1305.Error : Swift.Equatable {}
extension eMoneySDK.Poly1305.Error : Swift.Hashable {}
extension eMoneySDK.SDKLanguage : Swift.Equatable {}
extension eMoneySDK.SDKLanguage : Swift.Hashable {}
extension eMoneySDK.Environment : Swift.Equatable {}
extension eMoneySDK.Environment : Swift.Hashable {}
extension eMoneySDK.Environment : Swift.RawRepresentable {}
extension eMoneySDK.EWalletErrorCode : Swift.Equatable {}
extension eMoneySDK.EWalletErrorCode : Swift.Hashable {}
extension eMoneySDK.EWalletErrorCode : Swift.RawRepresentable {}
extension eMoneySDK.RSA.SignatureVariant : Swift.Equatable {}
extension eMoneySDK.RSA.SignatureVariant : Swift.Hashable {}
extension eMoneySDK.OCB.Mode : Swift.Equatable {}
extension eMoneySDK.OCB.Mode : Swift.Hashable {}
extension eMoneySDK.OCB.Error : Swift.Equatable {}
extension eMoneySDK.OCB.Error : Swift.Hashable {}
extension eMoneySDK.CS.BigInt.Sign : Swift.Equatable {}
extension eMoneySDK.CS.BigInt.Sign : Swift.Hashable {}
extension eMoneySDK.SHA3.Variant : Swift.Equatable {}
extension eMoneySDK.SHA3.Variant : Swift.Hashable {}
extension eMoneySDK.DropDown.DismissMode : Swift.Equatable {}
extension eMoneySDK.DropDown.DismissMode : Swift.Hashable {}
extension eMoneySDK.DropDown.Direction : Swift.Equatable {}
extension eMoneySDK.DropDown.Direction : Swift.Hashable {}
extension eMoneySDK.SignatureError : Swift.Equatable {}
extension eMoneySDK.SignatureError : Swift.Hashable {}
extension eMoneySDK.PKCS5.PBKDF2.Error : Swift.Equatable {}
extension eMoneySDK.PKCS5.PBKDF2.Error : Swift.Hashable {}
extension eMoneySDK.Rabbit.Error : Swift.Equatable {}
extension eMoneySDK.Rabbit.Error : Swift.Hashable {}
extension eMoneySDK.FSPagerView.ScrollDirection : Swift.Equatable {}
extension eMoneySDK.FSPagerView.ScrollDirection : Swift.Hashable {}
extension eMoneySDK.FSPagerView.ScrollDirection : Swift.RawRepresentable {}
extension eMoneySDK.GCM.Mode : Swift.Equatable {}
extension eMoneySDK.GCM.Mode : Swift.Hashable {}
extension eMoneySDK.GCM.Error : Swift.Equatable {}
extension eMoneySDK.GCM.Error : Swift.Hashable {}
extension eMoneySDK.CardType : Swift.Equatable {}
extension eMoneySDK.CardType : Swift.Hashable {}
extension eMoneySDK.CardType : Swift.RawRepresentable {}
extension eMoneySDK.CardIndustry : Swift.Equatable {}
extension eMoneySDK.CardIndustry : Swift.Hashable {}
extension eMoneySDK.CardIndustry : Swift.RawRepresentable {}
extension eMoneySDK.FloatingPanelReferenceEdge : Swift.Equatable {}
extension eMoneySDK.FloatingPanelReferenceEdge : Swift.Hashable {}
extension eMoneySDK.FloatingPanelReferenceEdge : Swift.RawRepresentable {}
extension eMoneySDK.FloatingPanelLayoutReferenceGuide : Swift.Equatable {}
extension eMoneySDK.FloatingPanelLayoutReferenceGuide : Swift.Hashable {}
extension eMoneySDK.FloatingPanelLayoutReferenceGuide : Swift.RawRepresentable {}
extension eMoneySDK.FloatingPanelLayoutContentBoundingGuide : Swift.Equatable {}
extension eMoneySDK.FloatingPanelLayoutContentBoundingGuide : Swift.Hashable {}
extension eMoneySDK.FloatingPanelLayoutContentBoundingGuide : Swift.RawRepresentable {}
extension eMoneySDK.PCBC.Error : Swift.Equatable {}
extension eMoneySDK.PCBC.Error : Swift.Hashable {}
extension eMoneySDK.TagListView.Alignment : Swift.Equatable {}
extension eMoneySDK.TagListView.Alignment : Swift.Hashable {}
extension eMoneySDK.TagListView.Alignment : Swift.RawRepresentable {}
extension eMoneySDK.RSA.RSAEncryptionVariant : Swift.Equatable {}
extension eMoneySDK.RSA.RSAEncryptionVariant : Swift.Hashable {}
